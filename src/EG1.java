/* Generated By:JavaCC: Do not edit this line. EG1.java */
import java.util.Set;
import java.util.HashSet;
import java.util.Arrays;
import java.util.Vector;
import java.util.StringTokenizer;
import java.util.HashMap;
import java.util.Iterator;
import java.io.File;
import java.io.UnsupportedEncodingException;

import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.Cursor;

import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;

import com.sleepycat.je.LockMode;
import com.sleepycat.je.OperationStatus;

enum LogicValue
{
    T, F, U
};

public class EG1 implements EG1Constants {
  // enumeration of three-valued logic


  static final String [] keywordList = new String []
  {
    "exit",
    "create",
    "table",
    "not",
    "null",
    "primary",
    "key",
    "foreign",
    "references",
    "int",
    "char",
    "date",
    "drop",
    "show",
    "tables",
    "desc",
    "select",
    "as",
    "from",
    "where",
    "and",
    "or",
    "is",
    "insert",
    "into",
    "values",
    "delete"
  };

  static final Set<String> keywordSet = new HashSet<String> (Arrays.asList(keywordList));
  static myDatabase myDB = new myDatabase();
  static EG1 parser;
  static String tmpColDef = "";
  static String tmpPriKey = "";
  static String tmpForKey = "";
  static String delim = "|";
  static String createTblName = "";
  static String dropTblName = "";
  static Vector<String > tblNameList = new Vector<String >();

  public static void main(String args []) throws ParseException
  {
    myDB.openDB();
    parser = new EG1(System.in);
    tblNameList = myDB.getDB("@table name");
    handleSyntaxError(parser);
  }

  public static void handleSyntaxError(EG1 parser)
  {
    try
    {
      parser.Start();
    }
    catch (ParseException e)
    {
      System.out.println("Syntax error");
      myDB.deleteTable(createTblName);
      parser = new EG1(System.in);
      handleSyntaxError(parser);
    }
  }

  public static void handleDBError(EG1 parser)
  {
    parser = new EG1(System.in);
    handleSyntaxError(parser);
  }

// Messages
  final public void DuplicateColumnDefError(String tblName) throws ParseException {
    System.out.println("Create table has failed: column definition is duplicated");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void TableExistenceError() throws ParseException {
    System.out.println("Create table has failed: table with the same name already exist");
    handleDBError(parser);
  }

  final public void CharLengthError() throws ParseException {
    System.out.println("Char length should be > 0");
    handleDBError(parser);
  }

  final public void DuplicatePrimaryKeyDefError(String tblName) throws ParseException {
    System.out.println("Create table has failed: primary key definition is duplicated");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void NonExistingColumnDefError(String tblName, String colName) throws ParseException {
    System.out.println("Create table has failed: '" + colName + "' does not exists in column definition");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void ReferenceTableExistenceError(String tblName) throws ParseException {
    System.out.println("Create table has failed: foreign key references non existing table");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void ReferenceNonPrimaryKeyError(String tblName) throws ParseException {
    System.out.println("Create table has failed: foreign key references non primary key column");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void ReferenceColumnExistenceError(String tblName) throws ParseException {
    System.out.println("Create table has failed: foreign key references non existing column");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void ReferenceTypeError(String tblName) throws ParseException {
    System.out.println("Create table has failed: foreign key references wrong type");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void NoSuchTable() throws ParseException {
    System.out.println("No such table");
    handleDBError(parser);
  }

  final public void DropReferencedTableError(String tblName) throws ParseException {
    System.out.println("Drop table has failed: '" + tblName + "' is referenced by other table");
    handleDBError(parser);
  }

  final public void ShowTablesNoTable() throws ParseException {
    System.out.println("There is no table");
    handleDBError(parser);
  }

  final public void InvalidDateRangeError() throws ParseException {
    System.out.println("Date value is in incorrect range");
    handleDBError(parser);
  }

  final public void InsertColumnExistenceError(String colName) throws ParseException {
    System.out.println("Insertion has failed: '" + colName + "' does not exist");
    handleDBError(parser);
  }

  final public void InsertDuplicateColumnError() throws ParseException {
    System.out.println("Insertion has failed: Column is duplicated");
    handleDBError(parser);
  }

  final public void InsertColumnNonNullableError(String colName) throws ParseException {
    System.out.println("Insertion has failed: '" + colName + "' is not nullable");
    handleDBError(parser);
  }

  final public void InsertTypeMismatchError() throws ParseException {
    System.out.println("Insertion has failed: Types are not matched");
    handleDBError(parser);
  }

  final public void InsertDuplicatePrimaryKeyError() throws ParseException {
    System.out.println("Insertion has failed: Primary key duplication");
    handleDBError(parser);
  }

  final public void InsertReferentialIntegrityError() throws ParseException {
    System.out.println("Insertion has failed: Referential integrity violation");
    handleDBError(parser);
  }

  final public void WhereIncomparableError() throws ParseException {
    System.out.println("Where clause try to compare incomparable values");
    handleDBError(parser);
  }

  final public void WhereTableNotSpecified() throws ParseException {
    System.out.println("Where clause try to reference tables which are not specified");
    handleDBError(parser);
  }

  final public void WhereColumnNotExist() throws ParseException {
    System.out.println("Where clause try to reference non existing column");
    handleDBError(parser);
  }

  final public void WhereAmbiguousReference() throws ParseException {
    System.out.println("Where clause contains ambiguous reference");
    handleDBError(parser);
  }

  final public void SelectTableExistenceError(String tblName) throws ParseException {
    System.out.println("Selection has failed: '" + tblName + "' does not exist");
    handleDBError(parser);
  }

  final public void SelectColumnResolveError(String colName) throws ParseException {
    System.out.println("Selection has failed: failed to resolve '" + colName + "'");
    handleDBError(parser);
  }

  final public void CreateTableSuccess() throws ParseException {
    System.out.println("'" + createTblName + "' table is created");
  }

  final public void DropSuccess() throws ParseException {
    System.out.println("'" + dropTblName + "' table is dropped");
  }

  final public void InsertResult() throws ParseException {
    System.out.println("The row is inserted");
  }

  final public void DeleteResult(int count) throws ParseException {
    System.out.printf("%d %s\u005cn", count, "row(s) are deleted");
  }

  final public void DeleteReferentialIntegrityPassed(int count) throws ParseException {
    System.out.printf("%d %s\u005cn", count, "row(s) are not deleted due to referential integrity");
  }

// Checking Functions
// Get column definition from DB and check duplicate columns
  final public boolean CheckDuplicateColumnDef(String tblName) throws ParseException {
    Vector < String > colNames = GetAllColumns(tblName);
    for (int i = 0; i < colNames.size() - 1; i++)
    {
      for (int j = i + 1; j < colNames.size(); j++)
      {
        if (colNames.elementAt(i).equals(colNames.elementAt(j)))
        {
          {if (true) return true;}
        }
      }
    }
    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

// Get table names from DB and check whether input table name exists in DB  final public boolean CheckTableExistence(String tblName) throws ParseException {
    Vector < String > tables = myDB.getDB("@table name");
    {if (true) return tables.contains(tblName);}
    throw new Error("Missing return statement in function");
  }

// Get primary key definition from this table and check whether it occurs more than one times  final public boolean CheckDuplicatePrimaryKeyDef(String tblName) throws ParseException {
    Vector < String > priKeys = myDB.getDB(tblName + " @primary key");
    {if (true) return priKeys.size() > 1;}
    throw new Error("Missing return statement in function");
  }

// Get primary key and foreign key definition from this table and check whether column names of this definition didn't occur in DB  final public String CheckNonExistingColumnDef(String tblName) throws ParseException {
    Vector < String > forKeys = myDB.getDB(tblName + " @foreign key");
    Vector < String > colNames = GetAllColumns(tblName);
    Vector < String > priKeyCols = GetPrimaryKeyColumns(tblName);
    // Check primary key definition
    for (int i = 0; i < priKeyCols.size(); i++)
    {
      String priKeyColAt = priKeyCols.elementAt(i);
      if (!colNames.contains(priKeyColAt))
      {
        {if (true) return priKeyColAt;}
      }
    }
    // Check foreign key definition
    for (int i = 0; i < forKeys.size(); i++)
    {
      String forKeyDef = forKeys.elementAt(i);
      StringTokenizer st3 = new StringTokenizer(forKeyDef, delim);
      while (st3.hasMoreTokens())
      {
        String colName = st3.nextToken();
        if (colName.contains("references"))
        {
          break;
        }
        else if (!colNames.contains(colName))
        {
          {if (true) return colName;}
        }
      }
    }
    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

// Get referenced table names from this table and check whether those referenced tables are really exist  final public boolean CheckReferenceTableExistence(String tblName) throws ParseException {
    Vector < String > tblNames = myDB.getDB("@table name");
    Vector < String > refTblNames = GetReferenceTables(tblName);
    for (int i = 0; i < refTblNames.size(); i++)
    {
      String refTblNameAt = refTblNames.elementAt(i);
      if (!tblNames.contains(refTblNameAt))
      {
        {if (true) return true;}
      }
    }
    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

// Get referenced columns from this table and check whether these columns are not primary key of referenced table  final public boolean CheckReferenceNonPrimaryKey(String tblName) throws ParseException {
    Vector < String > forKeys = myDB.getDB(tblName + " @foreign key");
    String refTblName = "";
    for (int i = 0; i < forKeys.size(); i++)
    {
      // Get referenced columns
      String forKeyDef = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyDef, delim);
      Vector < String > refCols = new Vector < String > ();
      boolean isRefCol = false;
      while (st.hasMoreTokens())
      {
        String tmpstr = st.nextToken();
        if (tmpstr.contains("references"))
        {
          refTblName = tmpstr.substring(12);
          isRefCol = true;
          continue;
        }
        else if (isRefCol)
        {
          String refColName = tmpstr;
          refCols.addElement(refColName);
        }
      }
      Vector < String > refPriKeyCols = GetPrimaryKeyColumns(refTblName);
      // Check whether all of referenced columns are primary key
      if (!refPriKeyCols.equals(refCols))
      {
        {if (true) return true;}
      }
    }
    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

// Get referenced columns from this table and check whether these columns are really exist in referenced table  final public boolean CheckReferenceColumnExistence(String tblName) throws ParseException {
    Vector < String > forKeys = myDB.getDB(tblName + " @foreign key");
    String refTblName = "";
    for (int i = 0; i < forKeys.size(); i++)
    {
      // Get referenced columns
      String forKeyDef = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyDef, delim);
      Vector < String > refCols = new Vector < String > ();
      boolean isRefCol = false;
      while (st.hasMoreTokens())
      {
        String tmpstr = st.nextToken();
        if (tmpstr.contains("references"))
        {
          refTblName = tmpstr.substring(12);
          isRefCol = true;
          continue;
        }
        else if (isRefCol)
        {
          String refColName = tmpstr;
          refCols.addElement(refColName);
        }
      }
      Vector < String > refRealColNames = GetAllColumns(refTblName);
      // Check whether all of referenced columns exist in referenced table
      for (int j = 0; j < refCols.size(); j++)
      {
        if (!refRealColNames.contains(refCols.elementAt(j)))
        {
          {if (true) return true;}
        }
      }
    }
    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

// Get type of referenced columns and referencing columns and check whether types of both columns are same  final public boolean CheckReferenceType(String tblName) throws ParseException {
    Vector < String > forKeys = myDB.getDB(tblName + " @foreign key");
    for (int i = 0; i < forKeys.size(); i++)
    {
      // Get referenced columns and referencing columns
      String forKeyDef = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyDef, delim);
      Vector < String > forCols = new Vector < String > ();
      Vector < String > refCols = new Vector < String > ();
      String refTblName = "";
      boolean isRefCol = false;
      while (st.hasMoreTokens())
      {
        String tmpstr = st.nextToken();
        if (tmpstr.contains("references"))
        {
          refTblName = tmpstr.substring(12);
          isRefCol = true;
          continue;
        }
        else if (isRefCol)
        {
          String refColName = tmpstr;
          refCols.addElement(refColName);
        }
        else
        {
          String forColName = tmpstr;
          forCols.addElement(forColName);
        }
      }
      // If number of referenced columns and referencing columns are different, type error
      if (refCols.size() != forCols.size())
      {
        {if (true) return true;}
      }
      // Check type of these columns one by one
      else
      {
        for (int j = 0; j < refCols.size(); j++)
        {
          String forColType = GetColumnType(tblName, forCols.elementAt(j));
          String refColType = GetColumnType(refTblName, refCols.elementAt(j));
          if (!forColType.equals(refColType))
          {
            if (forColType.contains("char") && refColType.contains("char"))
            {
              continue;
            }
            else
            {
              {if (true) return true;}
            }
          }
        }
      }
    }
    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

// Get table names of DB and check whether this table exists  final public boolean CheckNoSuchTable(String tblName) throws ParseException {
    Vector < String > tblNames = myDB.getDB("@table name");
    {if (true) return !tblNames.contains(tblName);}
    throw new Error("Missing return statement in function");
  }

// Get referenced table names of DB and check whether this table is referenced by other table  final public boolean CheckDropReferencedTable(String refTblName) throws ParseException {
    Vector < String > tblNames = myDB.getDB(refTblName + " @referenced by");
    {if (true) return !(tblNames.size() == 0);}
    throw new Error("Missing return statement in function");
  }

// Check whether there is no table  final public boolean CheckShowTablesNoTable() throws ParseException {
    Vector < String > tblNames = myDB.getDB("@table name");
    {if (true) return (tblNames.size() == 0);}
    throw new Error("Missing return statement in function");
  }

  final public String CheckInsertColumnExistence(String tblName, Vector < String > cols) throws ParseException {
    Vector < String > colNames = GetAllColumns(tblName);
    for (int i = 0; i < cols.size(); i++)
    {
      if (!colNames.contains(cols.elementAt(i)))
      {
        {if (true) return cols.elementAt(i);}
      }
    }
    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

// User defined error
  final public boolean CheckInsertDuplicateColumn(Vector < String > cols) throws ParseException {
    for (int i = 0; i < cols.size() - 1; i++)
    {
      for (int j = i + 1; j < cols.size(); j++)
      {
        if (cols.elementAt(i).equals(cols.elementAt(j)))
        {
          {if (true) return true;}
        }
      }
    }
    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

  final public void CheckInsertColumnNonNullableAndTypeMismatch(String tblName, Vector < String > cols, Vector < String > values) throws ParseException {
    Vector < String > allColumns = GetAllColumns(tblName);
    // if column list exists
    if (cols.size() > 0)
    { // if column list's size is not same as value list's size
      if (cols.size() != values.size())
      {
        InsertTypeMismatchError();
      }
      // if column list's size is smaller than entire column list
      // we should set null to columns that are not in column list
      if (cols.size() < allColumns.size())
      {
        for (int i = 0; i < allColumns.size(); i++)
        {
          String col = allColumns.elementAt(i);
          if (!cols.contains(col) && !IsColumnNullable(tblName, col))
          {
            InsertColumnNonNullableError(col);
          }
        }
      }
      else
      { // nullable error check
        for (int i = 0; i < cols.size(); i++)
        {
          String colAt = cols.elementAt(i);
          String valAt = values.elementAt(i);
          if (!IsColumnNullable(tblName, colAt) && valAt.equals("null"))
          {
            InsertColumnNonNullableError(colAt);
          }
        }
      }
      // type error check
      for (int i = 0; i < cols.size(); i++)
      {
        String colAt = cols.elementAt(i);
        String valAt = values.elementAt(i);
        String typAt = GetColumnType(tblName, colAt);
        // if value is int type
        if (typAt.equals("int"))
        {
          if (!valAt.equals("null") && !CheckInteger(valAt))
          {
            InsertTypeMismatchError();
          }
        }
        // if value is date type
        else if (typAt.equals("date"))
        {
          if (!valAt.equals("null") && !CheckDate(valAt))
          {
            InsertTypeMismatchError();
          }
        }
        // if value is char(...) type
        else if (typAt.substring(0, 4).equals("char"))
        {
          if (!valAt.equals("null") && !CheckString(valAt))
          {
            InsertTypeMismatchError();
          }
        }
      }
    }
    // if column list doesn't exist
    else
    {
      if (allColumns.size() != values.size())
      {
        InsertTypeMismatchError();
      }
      else
      {
        for (int i = 0; i < allColumns.size(); i++)
        {
          String colAt = allColumns.elementAt(i);
          String valAt = values.elementAt(i);
          String typAt = GetColumnType(tblName, colAt);
          // nullable error check
          if (!IsColumnNullable(tblName, colAt) && valAt.equals("null"))
          {
            InsertColumnNonNullableError(colAt);
          }
          // if value is int type
          if (typAt.equals("int"))
          {
            if (!valAt.equals("null") && !CheckInteger(valAt))
            {
              InsertTypeMismatchError();
            }
          }
          // if value is date type
          else if (typAt.equals("date"))
          {
            if (!valAt.equals("null") && !CheckDate(valAt))
            {
              InsertTypeMismatchError();
            }
          }
          // if value is char(...) type
          else if (typAt.substring(0, 4).equals("char"))
          {
            if (!valAt.equals("null") && !CheckString(valAt))
            {
              InsertTypeMismatchError();
            }
          }
        }
      }
    }
  }

  final public boolean CheckInsertDuplicatePrimaryKey(String tblName, Vector < String > cols, Vector < String > values) throws ParseException {
    if (myDB.getDB(tblName + " @primary key").size() == 0)
    {
      {if (true) return false;}
    }
    Vector < String > priKeyCols = GetPrimaryKeyColumns(tblName);
    Vector < Vector < String >> priKeyVals = GetRecordsByColumns(tblName, priKeyCols);
    Vector < String > priKeyVal = new Vector < String > ();
    for (int i = 0; i < priKeyCols.size(); i++)
    {
      String priKeyColAt = priKeyCols.elementAt(i);
      int priKeyColIdx;
      if (cols.size() > 0)
      {
        priKeyColIdx = cols.indexOf(priKeyColAt);
      }
      else
      {
        priKeyColIdx = GetColumnIndex(tblName, priKeyColAt);
      }
      String val = values.elementAt(priKeyColIdx);
      String typ = GetColumnType(tblName, priKeyColAt);
      if (typ.contains("char"))
      { // truncate string
        int typlen = Integer.parseInt(typ.substring(5, typ.length() - 1));
        int varlen = val.length() - 2;
        if (typlen < varlen)
        {
          val = val.substring(0, typlen + 1) + "'";
        }
      }
      else if (typ.contains("int"))
      {
        val = String.valueOf(Integer.parseInt(val));
      }
      priKeyVal.addElement(val);
    }
    {if (true) return priKeyVals.contains(priKeyVal);}
    throw new Error("Missing return statement in function");
  }

// Check whether foreign key references non-existing value in referenced table
  final public boolean CheckInsertReferentialIntegrity(String tblName, Vector < String > cols, Vector < String > values) throws ParseException {
    Vector < String > refTbls = GetReferenceTables(tblName);
    // for each foreign key definition
    for (int i = 0; i < refTbls.size(); i++)
    {
      String refTblAt = refTbls.elementAt(i);
      Vector < String > forKeyCols = GetForeignKeyColumns(tblName, refTblAt);
      Vector < Vector < String >> refVals = GetRecordsByColumns(refTblAt, GetPrimaryKeyColumns(refTblAt));
      // check if value of primary key of referenced table contains foreign key value of this table
      Vector < String > forKeyVals = new Vector < String > ();
      for (int j = 0; j < forKeyCols.size(); j++)
      {
        String forKeyColAt = forKeyCols.elementAt(j);
        int forKeyColIdx;
        if (cols.size() > 0)
        {
          forKeyColIdx = cols.indexOf(forKeyColAt);
        }
        else
        {
          forKeyColIdx = GetColumnIndex(tblName, forKeyColAt);
        }
        String val = values.elementAt(forKeyColIdx);
        String typ = GetColumnType(tblName, forKeyColAt);
        if (val.equals("null"))
        {
          {if (true) return false;}
        }
        if (typ.contains("char"))
        { // truncate string
          int typlen = Integer.parseInt(typ.substring(5, typ.length() - 1));
          int varlen = val.length() - 2;
          if (typlen < varlen)
          {
            val = val.substring(0, typlen + 1) + "'";
          }
        }
        else if (typ.contains("int"))
        {
          val = String.valueOf(Integer.parseInt(val));
        }
        forKeyVals.addElement(val);
      }
      if (!refVals.contains(forKeyVals))
      {
        {if (true) return true;}
      }
    }
    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

  final public String CheckSelectTableExistence(Vector < String > tblNames) throws ParseException {
    Vector < String > allTblNames = myDB.getDB("@table name");
    for (int i = 0; i < tblNames.size(); i++)
    {
      String tblNameAt = tblNames.elementAt(i);
      if (!allTblNames.contains(tblNameAt))
      {
        {if (true) return tblNameAt;}
      }
    }
    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public String CheckSelectColumnResolve(Vector < String > tblNames, Vector < String > colNames) throws ParseException {
    for (int i = 0; i < colNames.size(); i++)
    {
      String colNameAt = colNames.elementAt(i);
      // tbl.col form
      if (colNameAt.contains("."))
      {
        StringTokenizer st = new StringTokenizer(colNameAt, ".");
        String tblName = st.nextToken();
        String colName = st.nextToken();
        if (!tblNames.contains(tblName))
        {
          {if (true) return colName;}
        }
        Vector < String > allCols = GetAllColumns(tblName);
        if (!allCols.contains(colName))
        {
          {if (true) return colName;}
        }
      }
      // col form
      else
      {
        int cnt = 0;
        for (int j = 0; j < tblNames.size(); j++)
        {
          String tblNameAt = tblNames.elementAt(j);
          Vector < String > allCols = GetAllColumns(tblNameAt);
          if (allCols.contains(colNameAt))
          {
            cnt++;
          }
        }
        if (cnt != 1)
        {
          {if (true) return colNameAt;}
        }
      }
    }
    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

// Utility Functions
  final public Vector < String > GetReferenceTables(String tblName) throws ParseException {
    Vector < String > forKeyDefs = myDB.getDB(tblName + " @foreign key");
    Vector < String > refTbls = new Vector < String > ();
    for (int i = 0; i < forKeyDefs.size(); i++)
    {
      String forKeyDefAt = forKeyDefs.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyDefAt, delim);
      while (st.hasMoreTokens())
      {
        String refTblName = st.nextToken();
        if (refTblName.contains("references"))
        {
          refTblName = refTblName.substring(12);
          refTbls.addElement(refTblName);
          break;
        }
      }
    }
    {if (true) return refTbls;}
    throw new Error("Missing return statement in function");
  }

// Get record's value by column name
  final public Vector < Vector < String >> GetRecordsByColumns(String tblName, Vector < String > colNames) throws ParseException {
    Vector < Vector < String >> allRecords = GetAllRecords(tblName);
    Vector < Vector < String >> records = new Vector < Vector < String >> ();
    Vector < Integer > colIndices = new Vector < Integer > ();
    for (int i = 0; i < colNames.size(); i++)
    {
      colIndices.addElement(GetColumnIndex(tblName, colNames.elementAt(i)));
    }
    for (int i = 0; i < allRecords.size(); i++)
    {
      Vector < String > recordAt = allRecords.elementAt(i);
      Vector < String > newRecord = new Vector < String > ();
      for (int j = 0; j < colNames.size(); j++)
      {
        newRecord.addElement(recordAt.elementAt(colIndices.elementAt(j)));
      }
      records.addElement(newRecord);
    }
    {if (true) return records;}
    throw new Error("Missing return statement in function");
  }

  final public int GetColumnIndex(String tblName, String colName) throws ParseException {
    Vector < String > colNames = GetAllColumns(tblName);
    {if (true) return colNames.indexOf(colName);}
    throw new Error("Missing return statement in function");
  }

  final public Vector < String > GetPrimaryKeyColumns(String tblName) throws ParseException {
    Vector < String > priKeyCols = new Vector < String > ();
    if (myDB.getDB(tblName + " @primary key").size() > 0)
    {
      String priKeyColStr = myDB.getDB(tblName + " @primary key").elementAt(0);
      StringTokenizer st = new StringTokenizer(priKeyColStr, delim);
      while (st.hasMoreTokens())
      {
        String col = st.nextToken();
        priKeyCols.addElement(col);
      }
    }
    {if (true) return priKeyCols;}
    throw new Error("Missing return statement in function");
  }

  final public Vector < String > GetForeignKeyColumns(String tblName, String refTblName) throws ParseException {
    Vector < String > forKeyCols = new Vector < String > ();
    Vector < String > forKeyDefs = myDB.getDB(tblName + " @foreign key");
    for (int i = 0; i < forKeyDefs.size(); i++)
    {
      forKeyCols = new Vector < String > ();
      String forKeyDefAt = forKeyDefs.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyDefAt, delim);
      while (st.hasMoreTokens())
      {
        String col = st.nextToken();
        if (col.contains("references"))
        {
          String refTbl = col.substring(12);
          if (refTbl.equals(refTblName))
          {
            {if (true) return forKeyCols;}
          }
          else
          {
            break;
          }
        }
        else
        {
          forKeyCols.addElement(col);
        }
      }
    }
    {if (true) return forKeyCols;}
    throw new Error("Missing return statement in function");
  }

  final public Vector < String > GetAllColumns(String tblName) throws ParseException {
    Vector < String > colNames = new Vector < String > ();
    String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDefStr, delim);
    while (st.hasMoreTokens())
    {
      String colName = st.nextToken();
      String colType = st.nextToken();
      colNames.addElement(colName);
    }
    {if (true) return colNames;}
    throw new Error("Missing return statement in function");
  }

  final public Vector < Vector < String >> GetAllRecords(String tblName) throws ParseException {
    Vector < String > recordsStr = myDB.getDB(tblName + " @record");
    Vector < Vector < String >> recordsVect = new Vector < Vector < String >> ();
    for (int i = 0; i < recordsStr.size(); i++)
    {
      String recordStrAt = recordsStr.elementAt(i);
      Vector < String > record = new Vector < String > ();
      StringTokenizer st = new StringTokenizer(recordStrAt, delim);
      while (st.hasMoreTokens())
      {
        String val = st.nextToken();
        record.addElement(val);
      }
      recordsVect.addElement(record);
    }
    {if (true) return recordsVect;}
    throw new Error("Missing return statement in function");
  }

  final public Vector < Vector < String >> GetJoinedRecords(Vector < String > tblNames) throws ParseException {
    // a.x a.y b.z b.w
    Vector < Vector < String >> result = new Vector < Vector < String >> ();
    Vector < Vector < String >> tmpResult;
    Vector < String > allCols = new Vector < String > ();
    for (int i = 0; i < tblNames.size(); i++)
    {
      String tblNameAt = tblNames.elementAt(i);
      Vector < String > cols = GetAllColumns(tblNameAt);
      for (int j = 0; j < cols.size(); j++)
      {
        allCols.addElement(tblNameAt + "." + cols.elementAt(j));
      }
    }
    result.addElement(allCols);
    Vector < String > tmp = new Vector < String > (tblNames);
    tmpResult = CartesianProduct(tmp);
    for (int i = 0; i < tmpResult.size(); i++)
    {
      result.addElement(tmpResult.elementAt(i));
    }
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

// Get type of column
  final public String GetColumnType(String tblName, String colName) throws ParseException {
    String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDefStr, delim);
    while (st.hasMoreTokens())
    {
      String _colName = st.nextToken();
      String colType = st.nextToken();
      if (colName.equals(_colName))
      {
        StringTokenizer st2 = new StringTokenizer(colType, "*");
        {if (true) return st2.nextToken();}
      }
    }
    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

// recursive cartesian product
  final public Vector < Vector < String >> CartesianProduct(Vector < String > tblNames) throws ParseException {
    String tblNameAt = tblNames.elementAt(0);
    Vector < Vector < String >> left = GetAllRecords(tblNameAt);
    Vector < Vector < String >> result = new Vector < Vector < String >> ();
    if (tblNames.size() < 2)
    {
      {if (true) return left;}
    }
    else
    {
      tblNames.remove(0);
      Vector < Vector < String >> right = CartesianProduct(tblNames);
      for (int i = 0; i < left.size(); i++)
      {
        Vector < String > leftRecordAt = left.elementAt(i);
        for (int j = 0; j < right.size(); j++)
        {
          Vector < String > rightRecordAt = right.elementAt(j);
          Vector < String > tmp = new Vector < String > (leftRecordAt);
          for (int k = 0; k < rightRecordAt.size(); k++)
          {
            String val = rightRecordAt.elementAt(k);
            tmp.addElement(val);
          }
          result.addElement(tmp);
        }
      }
      {if (true) return result;}
    }
    throw new Error("Missing return statement in function");
  }

// Change columns of primary key to not null
  final public void ChangeToNotNull(String tblName) throws ParseException {
    Vector < String > priKeys = myDB.getDB(tblName + " @primary key");
    if (priKeys.size() > 0)
    {
      // Get primary keys
      Vector < String > priKeyCols = GetPrimaryKeyColumns(tblName);
      String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);
      myDB.deleteDB(tblName + " @column definition");
      StringTokenizer st2 = new StringTokenizer(colDefStr, delim);
      String newColDef = "";
      // Change type of primary keys to not null by deleting and re-inserting primary key data
      while (st2.hasMoreTokens())
      {
        String colName = st2.nextToken();
        String colType = st2.nextToken();
        StringTokenizer st3 = new StringTokenizer(colType, "*");
        String realColType = st3.nextToken();
        if (priKeyCols.contains(colName) && !st3.hasMoreTokens())
        {
          newColDef += "|" + colName + "|" + realColType + "*not null";
        }
        else
        {
          newColDef += "|" + colName + "|" + colType;
        }
      }
      myDB.putDB(tblName + " @column definition", newColDef.substring(1));
    }
  }

// Perform drop table query  final public void DropTable(String tblName) throws ParseException {
    myDB.deleteTable(tblName);
    myDB.deleteDB("@table name");
    tblNameList.remove(tblName);
    for (int i = 0; i < tblNameList.size(); i++)
    {
      myDB.putDB("@table name", tblNameList.elementAt(i));
    }
  }

// Perform show tables query  final public void ShowTables() throws ParseException {
    Vector < String > tblNames = myDB.getDB("@table name");
    System.out.println("-------------------------");
    for (int i = 0; i < tblNames.size(); i++)
    {
      System.out.println(tblNames.elementAt(i));
    }
    System.out.println("-------------------------");
  }

// Check whether given column is primary key column
  final public boolean IsPrimaryKey(String tblName, String colName) throws ParseException {
    Vector < String > priKeyCols = GetPrimaryKeyColumns(tblName);
    {if (true) return priKeyCols.contains(colName);}
    throw new Error("Missing return statement in function");
  }

// Check whether given column is foreign key column  final public boolean IsForeignKey(String tblName, String colName) throws ParseException {
    Vector < String > forKeys = myDB.getDB(tblName + " @foreign key");
    for (int i = 0; i < forKeys.size(); i++)
    {
      String forKeyDef = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyDef, delim);
      while (st.hasMoreTokens())
      {
        String tmp = st.nextToken();
        if (tmp.contains("references"))
        {
          break;
        }
        else if (tmp.equals(colName))
        {
          {if (true) return true;}
        }
      }
    }
    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

// Perform desc query
  final public void Desc(String tblName) throws ParseException {
    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDef, delim);
    System.out.println("------------------------------------------------------------");
    System.out.println("table_name [" + tblName + "]");
    System.out.printf("%-25s%-15s%-10s%-10s\u005cn", "column_name", "type", "null", "key");
    while (st.hasMoreTokens())
    {
      String colName = st.nextToken();
      String colType = st.nextToken();
      boolean isNotNull = false;
      boolean isPriKey = IsPrimaryKey(tblName, colName);
      boolean isForKey = IsForeignKey(tblName, colName);
      StringTokenizer st2 = new StringTokenizer(colType, "*");
      String realColType = st2.nextToken();
      if (st2.hasMoreTokens())
      {
        isNotNull = true;
      }
      System.out.printf("%-25s%-15s", colName, realColType);
      if (isNotNull)
      {
        System.out.printf("%-10s", "N");
      }
      else
      {
        System.out.printf("%-10s", "Y");
      }
      if (isPriKey && isForKey)
      {
        System.out.printf("%-10s\u005cn", "PRI/FOR");
      }
      else if (isPriKey)
      {
        System.out.printf("%-10s\u005cn", "PRI");
      }
      else if (isForKey)
      {
        System.out.printf("%-10s\u005cn", "FOR");
      }
      else
      {
        System.out.print("\u005cn");
      }
    }
    System.out.println("------------------------------------------------------------");
  }

  final public boolean CheckInteger(String num) throws ParseException {
    try
    {
      Integer.parseInt(num);
    }
    catch (NumberFormatException e)
    {
      {if (true) return false;}
    }
    {if (true) return true;}
    throw new Error("Missing return statement in function");
  }

  final public boolean CheckDate(String date) throws ParseException {
  boolean isLeapYear = false;
  String year;
  String month;
  String day;
  int yearInt = 0, monthInt = 0, dayInt = 0;
    StringTokenizer st = new StringTokenizer(date, "-");
    year = new String();
    month = new String();
    day = new String();
    year = st.nextToken();
    if (CheckInteger(year) && year.length() == 4 && st.hasMoreTokens())
    {
      month = st.nextToken();
      yearInt = Integer.parseInt(year);
      // leap year check
      if (yearInt % 4 == 0)
      {
        if (yearInt % 100 == 0)
        {
          if (yearInt % 400 == 0)
          {
            isLeapYear = true;
          }
          else
          {
            isLeapYear = false;
          }
        }
        else
        {
          isLeapYear = true;
        }
      }
      else
      {
        isLeapYear = false;
      }
      if (CheckInteger(month) && month.length() == 2 && st.hasMoreTokens())
      {
        day = st.nextToken();
        monthInt = Integer.parseInt(month);
        if (CheckInteger(day) && day.length() == 2)
        {
          dayInt = Integer.parseInt(day);
        }
        else
        {
          {if (true) return false;}
        }
      }
      else
      {
        {if (true) return false;}
      }
    }
    else
    {
      {if (true) return false;}
    }
    // date range checking
    switch (monthInt)
    {
      case 2 : if (isLeapYear)
      {
        if (dayInt < 1 || dayInt > 29)
        {
          InvalidDateRangeError();
          {if (true) return false;}
        }
      }
      else
      {
        if (dayInt < 1 || dayInt > 28)
        {
          InvalidDateRangeError();
          {if (true) return false;}
        }
      }
      break;
      case 1 : case 3 : case 5 : case 7 : case 8 : case 10 : case 12 : if (dayInt < 1 || dayInt > 31)
      {
        InvalidDateRangeError();
        {if (true) return false;}
      }
      break;
      case 4 : case 6 : case 9 : case 11 : if (dayInt < 1 || dayInt > 30)
      {
        InvalidDateRangeError();
        {if (true) return false;}
      }
      break;
      default : InvalidDateRangeError();
      {if (true) return false;}
    }
    {if (true) return true;}
    throw new Error("Missing return statement in function");
  }

  final public boolean CheckString(String str) throws ParseException {
    {if (true) return str.startsWith("'") && str.endsWith("'");}
    throw new Error("Missing return statement in function");
  }

  final public void InsertValues(String tblName, Vector < String > cols, Vector < String > values) throws ParseException {
    Vector < String > colNames = GetAllColumns(tblName);
    String valArr [ ] = new String [ colNames.size() ];
    for (int i = 0; i < valArr.length; i++)
    {
      valArr [ i ] = "null";
    }
    // if column list exists
    if (cols.size() > 0)
    {
      for (int i = 0; i < cols.size(); i++)
      {
        String col = cols.elementAt(i);
        String val = values.elementAt(i);
        String typ = GetColumnType(tblName, col);
        if (val.equals("null"))
        {
          continue;
        }
        else if (typ.contains("char"))
        { // truncate string
          int typlen = Integer.parseInt(typ.substring(5, typ.length() - 1));
          int varlen = val.length() - 2;
          if (typlen < varlen)
          {
            val = val.substring(0, typlen + 1) + "'";
          }
        }
        else if (typ.contains("int"))
        {
          val = String.valueOf(Integer.parseInt(val));
        }
        int match = colNames.indexOf(col);
        valArr [ match ] = val;
      }
    }
    // if column list does not exists
    else
    {
      for (int i = 0; i < values.size(); i++)
      {
        String col = GetAllColumns(tblName).elementAt(i);
        String val = values.elementAt(i);
        String typ = GetColumnType(tblName, col);
        if (val.equals("null"))
        {
          continue;
        }
        else if (typ.contains("char"))
        { // truncate string
          int typlen = Integer.parseInt(typ.substring(5, typ.length() - 1));
          int varlen = val.length() - 2;
          if (typlen < varlen)
          {
            val = val.substring(0, typlen + 1) + "'";
          }
        }
        else if (typ.contains("int"))
        {
          val = String.valueOf(Integer.parseInt(val));
        }
        valArr [ i ] = val;
      }
    }
    String valStr = "";
    for (int i = 0; i < valArr.length; i++)
    {
      valStr += delim + valArr [ i ];
    }
    valStr = valStr.substring(1);
    myDB.putDB(tblName + " @record", valStr);
  }

  final public boolean IsColumnNullable(String tblName, String colName) throws ParseException {
    String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDefStr, delim);
    while (st.hasMoreTokens())
    {
      String col = st.nextToken();
      String colType = st.nextToken();
      if (col.equals(colName))
      {
        StringTokenizer st2 = new StringTokenizer(colType, "*");
        st2.nextToken();
        {if (true) return !st2.hasMoreTokens();}
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public void UpdateTable(String tblName, Vector < Vector < String >> allRecords) throws ParseException {
    myDB.deleteDB(tblName + " @record");
    for (int i = 0; i < allRecords.size(); i++)
    {
      Vector < String > recordAt = allRecords.elementAt(i);
      String recordStrAt = new String();
      for (int j = 0; j < recordAt.size(); j++)
      {
        String val = recordAt.elementAt(j);
        recordStrAt += delim + val;
      }
      recordStrAt = recordStrAt.substring(1);
      myDB.putDB(tblName + " @record", recordStrAt);
    }
  }

  final public void DeleteRecords(String tblName, Vector < LogicValue > evalResult, Vector < Boolean > performDelete) throws ParseException {
    Vector < String > recordsStr = myDB.getDB(tblName + " @record");
    Vector < String > result = new Vector < String > ();
    int delCnt = 0, notDelCnt = 0;
    myDB.deleteDB(tblName + " @record");
    // if there is 0 record in table
    if (evalResult.size() == 0 && performDelete == null)
    {
      DeleteResult(0);
      DeleteReferentialIntegrityPassed(0);
      {if (true) return;}
    }
    // if there is 0 record in table
    if (evalResult.size() == 0 && performDelete.size() == 0)
    {
      DeleteResult(0);
      DeleteReferentialIntegrityPassed(0);
      {if (true) return;}
    }
    for (int i = 0; i < recordsStr.size(); i++)
    {
      String recordStrAt = recordsStr.elementAt(i);
      LogicValue eval = evalResult.elementAt(i);
      if (performDelete != null)
      {
        boolean delete = performDelete.elementAt(i);
        if (eval == LogicValue.T && delete)
        {
          delCnt++;
        }
        else if (eval == LogicValue.T && !delete)
        {
          notDelCnt++;
        }
        if (eval != LogicValue.T || !delete)
        {
          result.addElement(recordStrAt);
        }
      }
      else
      {
        if (eval == LogicValue.T)
        {
          delCnt++;
        }
        else
        {
          result.addElement(recordStrAt);
        }
      }
    }
    for (int i = 0; i < result.size(); i++)
    {
      myDB.putDB(tblName + " @record", result.elementAt(i));
    }
    DeleteResult(delCnt);
    DeleteReferentialIntegrityPassed(notDelCnt);
  }

  final public void DeleteRecordsCascade(String tblName, Vector < LogicValue > evalResult, Vector < Boolean > performDelete) throws ParseException {
    Vector < String > recordsStr = myDB.getDB(tblName + " @record");
    Vector < String > refTblNames = myDB.getDB(tblName + " @referenced by");
    Vector < String > result = new Vector < String > ();
    Vector < String > priKeyCols = GetPrimaryKeyColumns(tblName);
    Vector < Vector < String >> priKeyVals = GetRecordsByColumns(tblName, priKeyCols);
    // if there is 0 record in table, do nothing
    if (evalResult.size() == 0 && performDelete.size() == 0)
    {
      {if (true) return;}
    }
    // for each primary key value, update corresponding foreign key values to null if they are nullable
    for (int i = 0; i < priKeyVals.size(); i++)
    {
      Vector < String > priKeyValAt = priKeyVals.elementAt(i);
      boolean delete = performDelete.elementAt(i);
      LogicValue eval = evalResult.elementAt(i);
      if (eval == LogicValue.T && delete)
      {
        for (int j = 0; j < refTblNames.size(); j++)
        {
          String refTblNameAt = refTblNames.elementAt(j);
          Vector < String > forKeyCols = GetForeignKeyColumns(refTblNameAt, tblName);
          Vector < Vector < String >> forKeyVals = GetRecordsByColumns(refTblNameAt, forKeyCols);
          Vector < Vector < String >> allRecordsRefTbl = GetAllRecords(refTblNameAt);
          for (int k = 0; k < forKeyVals.size(); k++)
          {
            Vector < String > forKeyValAt = forKeyVals.elementAt(k);
            Vector < String > recordAt = allRecordsRefTbl.elementAt(k);
            if (priKeyValAt.equals(forKeyValAt))
            {
              // update to null
              for (int l = 0; l < forKeyCols.size(); l++)
              {
                String forKeyColAt = forKeyCols.elementAt(l);
                int idx = GetColumnIndex(refTblNameAt, forKeyColAt);
                recordAt.setElementAt("null", idx);
              }
              allRecordsRefTbl.setElementAt(recordAt, k);
            }
          }
          // update table to updated records
          UpdateTable(refTblNameAt, allRecordsRefTbl);
        }
      }
    }
    // delete records of this table
    DeleteRecords(tblName, evalResult, performDelete);
  }

  final public void CascadeDelete(String tblName, Vector < LogicValue > evalResult) throws ParseException {
    Vector < Boolean > performDelete = new Vector < Boolean > ();
    Vector < String > refTblNames = myDB.getDB(tblName + " @referenced by");
    // no table is referencing this table, so just delete records
    if (refTblNames.size() == 0)
    {
      DeleteRecords(tblName, evalResult, null);
    }
    // if there are some tables referencing this table
    else
    {
      Vector < String > priKeyCols = GetPrimaryKeyColumns(tblName);
      Vector < Vector < String >> priKeyVals = GetRecordsByColumns(tblName, priKeyCols);
      for (int i = 0; i < priKeyVals.size(); i++)
      {
        LogicValue eval = evalResult.elementAt(i);
        Vector < String > priKeyValAt = priKeyVals.elementAt(i);
        if (eval != LogicValue.T)
        {
          performDelete.addElement(false);
          continue;
        }
        else
        {
          boolean delete = true;
          for (int j = 0; j < refTblNames.size(); j++)
          {
            String refTblNameAt = refTblNames.elementAt(j);
            Vector < String > forKeyCols = GetForeignKeyColumns(refTblNameAt, tblName);
            Vector < Vector < String >> forKeyVals = GetRecordsByColumns(refTblNameAt, forKeyCols);
            boolean isColumnNonNullable = false;
            // if there is a record referencing this primary key value, delete is not performed for this record
            if (forKeyVals.contains(priKeyValAt))
            {
              for (int k = 0; k < forKeyCols.size(); k++)
              {
                String forKeyColAt = forKeyCols.elementAt(k);
                if (!IsColumnNullable(refTblNameAt, forKeyColAt))
                {
                  isColumnNonNullable = true;
                  delete = false;
                  break;
                }
              }
              if (isColumnNonNullable)
              {
                break;
              }
            }
          }
          performDelete.addElement(delete);
        }
      }
      DeleteRecordsCascade(tblName, evalResult, performDelete);
    }
  }

  final public void SelectPrint(Vector < Vector < String >> records, Vector < String > colNames) throws ParseException {
    if (colNames == null)
    {
      colNames = records.elementAt(0);
    }
    String pretty = new String();
    for (int i = 0; i < colNames.size(); i++)
    {
      pretty += "+------------------------";
    }
    pretty += "+";
    System.out.println(pretty);
    String colStr = new String();
    for (int i = 0; i < colNames.size(); i++)
    {
      String colAt = colNames.elementAt(i);
      if (colAt.contains("."))
      {
        StringTokenizer st = new StringTokenizer(colAt, ".");
        st.nextToken();
        colAt = st.nextToken();
      }
      System.out.printf("%-25s", "| " + colAt.toUpperCase());
    }
    System.out.printf("|\u005cn");
    System.out.println(pretty);
    for (int i = 1; i < records.size(); i++)
    {
      Vector < String > recordAt = records.elementAt(i);
      for (int j = 0; j < recordAt.size(); j++)
      {
        String val = recordAt.elementAt(j);
        if (CheckString(val))
        {
          val = val.substring(1, val.length() - 1);
        }
        System.out.printf("%-25s", "| " + val);
      }
      System.out.printf("|\u005cn");
    }
    System.out.println(pretty);
  }

// Check if given string is keyword
  final public boolean IsKeyword(String s) throws ParseException {
    {if (true) return keywordSet.contains(s.toLowerCase());}
    throw new Error("Missing return statement in function");
  }

// Parsing Functions
  final public void Command() throws ParseException {
    QueryList();
  }

  final public void QueryList() throws ParseException {
    label_1:
    while (true) {
      Query();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXIT:
      case CREATE_TABLE:
      case DROP_TABLE:
      case SHOW_TABLES:
      case DESC:
      case SELECT:
      case INSERT_INTO:
      case DELETE_FROM:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
    }
  }

  final public void Query() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATE_TABLE:
      CreateTableQuery();
      break;
    case DROP_TABLE:
      DropTableQuery();
      break;
    case SHOW_TABLES:
      ShowTablesQuery();
      break;
    case DESC:
      DescQuery();
      break;
    case SELECT:
      SelectQuery();
      break;
    case INSERT_INTO:
      InsertQuery();
      break;
    case DELETE_FROM:
      DeleteQuery();
      break;
    case EXIT:
      ExitQuery();
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ExitQuery() throws ParseException {
    jj_consume_token(EXIT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case 1:
    case 2:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 1:
        jj_consume_token(1);
        break;
      case 2:
        jj_consume_token(2);
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    myDB.closeDB();
    System.exit(0);
  }

  final public void CreateTableQuery() throws ParseException {
  String tblName;
  String colName;
  boolean isNewLine = false;
    jj_consume_token(CREATE_TABLE);
    tblName = TableName();
    if (CheckTableExistence(tblName))
    {
      TableExistenceError();
    }
    TableElementList(tblName);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case 1:
    case 2:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 1:
        jj_consume_token(1);
        break;
      case 2:
        jj_consume_token(2);
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        isNewLine = true;
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    myDB.putDB(tblName + " @column definition", tmpColDef.substring(1));
    tmpColDef = "";
    tmpPriKey = "";
    tmpForKey = "";
    if (CheckDuplicateColumnDef(tblName))
    {
      DuplicateColumnDefError(tblName);
    }
    else if (CheckDuplicatePrimaryKeyDef(tblName))
    {
      DuplicatePrimaryKeyDefError(tblName);
    }
    else if ((colName = CheckNonExistingColumnDef(tblName)) != null)
    {
      NonExistingColumnDefError(tblName, colName);
    }
    else if (CheckReferenceTableExistence(tblName))
    {
      ReferenceTableExistenceError(tblName);
    }
    else if (CheckReferenceColumnExistence(tblName))
    {
      ReferenceColumnExistenceError(tblName);
    }
    else if (CheckReferenceNonPrimaryKey(tblName))
    {
      ReferenceNonPrimaryKeyError(tblName);
    }
    else if (CheckReferenceType(tblName))
    {
      ReferenceTypeError(tblName);
    }
    ChangeToNotNull(tblName);
    createTblName = tblName;
    myDB.putDB("@table name", tblName);
    tblNameList.addElement(tblName);
    CreateTableSuccess();
    if (isNewLine)
    {
      System.out.print("SQL_2011-11693 > ");
    }
  }

  final public void TableElementList(String tblName) throws ParseException {
    jj_consume_token(LEFT_PAREN);
    TableElement(tblName);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMMA);
      TableElement(tblName);
    }
    jj_consume_token(RIGHT_PAREN);
  }

  final public void TableElement(String tblName) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ALPHABET:
    case LEGAL_IDENTIFIER:
      ColumnDefinition();
      break;
    case PRIMARY_KEY:
    case FOREIGN_KEY:
      TableConstraintDefinition(tblName);
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ColumnDefinition() throws ParseException {
  String colName = "";
  String dataType = "";
  String notNull = "";
    if (jj_2_1(2147483647)) {
      colName = ColumnName();
      dataType = DataType();
      jj_consume_token(NOT_NULL);
        notNull = "*not null";
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:
        colName = ColumnName();
        dataType = DataType();
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    tmpColDef += delim + colName + delim + dataType + notNull;
  }

  final public void TableConstraintDefinition(String tblName) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMARY_KEY:
      PrimaryKeyConstraint(tblName);
      break;
    case FOREIGN_KEY:
      ReferentialKeyConstraint(tblName);
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void PrimaryKeyConstraint(String tblName) throws ParseException {
    jj_consume_token(PRIMARY_KEY);
    ColumnNameList(true);
    myDB.putDB(tblName + " @primary key", tmpPriKey.substring(1));
  }

  final public void ReferentialKeyConstraint(String tblName) throws ParseException {
  String referedTblName;
    jj_consume_token(FOREIGN_KEY);
    ColumnNameList(false);
    jj_consume_token(REFERENCES);
    referedTblName = TableName();
    myDB.putDB(referedTblName + " @referenced by", tblName);
    tmpForKey += delim + "@references&" + referedTblName;
    ColumnNameList(false);
    myDB.putDB(tblName + " @foreign key", tmpForKey.substring(1));
    tmpForKey = "";
  }

  final public void ColumnNameList(boolean isPrimaryKey) throws ParseException {
  String colName;
    jj_consume_token(LEFT_PAREN);
    colName = ColumnName();
    if (isPrimaryKey)
    {
      tmpPriKey += delim + colName;
    }
    else
    {
      tmpForKey += delim + colName;
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_3;
      }
      jj_consume_token(COMMA);
      colName = ColumnName();
      if (isPrimaryKey)
      {
        tmpPriKey += delim + colName;
      }
      else
      {
        tmpForKey += delim + colName;
      }
    }
    jj_consume_token(RIGHT_PAREN);
  }

  final public String DataType() throws ParseException {
  Token size;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      jj_consume_token(INT);
    {if (true) return "int";}
      break;
    case CHAR:
      jj_consume_token(CHAR);
      jj_consume_token(LEFT_PAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT_VALUE:
        size = jj_consume_token(INT_VALUE);
        break;
      case DIGIT:
        size = jj_consume_token(DIGIT);
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RIGHT_PAREN);
      if (Integer.parseInt(size.image) <= 0) CharLengthError();
      {if (true) return "char(" + Integer.toString(Integer.parseInt(size.image)) + ")";}
      break;
    case DATE:
      jj_consume_token(DATE);
    {if (true) return "date";}
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String TableName() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEGAL_IDENTIFIER:
      t = jj_consume_token(LEGAL_IDENTIFIER);
      if (IsKeyword(t.image))
      {
        {if (true) throw new ParseException();}
      }
      break;
    case ALPHABET:
      t = jj_consume_token(ALPHABET);
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return t.image.toLowerCase();}
    throw new Error("Missing return statement in function");
  }

  final public String ColumnName() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEGAL_IDENTIFIER:
      t = jj_consume_token(LEGAL_IDENTIFIER);
      if (IsKeyword(t.image))
      {
        {if (true) throw new ParseException();}
      }
      break;
    case ALPHABET:
      t = jj_consume_token(ALPHABET);
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return t.image.toLowerCase();}
    throw new Error("Missing return statement in function");
  }

  final public void DropTableQuery() throws ParseException {
  String tblName;
  boolean isNewLine = false;
    jj_consume_token(DROP_TABLE);
    tblName = TableName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case 1:
    case 2:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 1:
        jj_consume_token(1);
        break;
      case 2:
        jj_consume_token(2);
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        isNewLine = true;
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (CheckNoSuchTable(tblName))
    {
      NoSuchTable();
    }
    else if (CheckDropReferencedTable(tblName))
    {
      DropReferencedTableError(tblName);
    }
    else
    {
      dropTblName = tblName;
      DropTable(tblName);
    }
    DropSuccess();
    if (isNewLine)
    {
      System.out.print("SQL_2011-11693 > ");
    }
  }

  final public void ShowTablesQuery() throws ParseException {
  boolean isNewLine = false;
    jj_consume_token(SHOW_TABLES);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case 1:
    case 2:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 1:
        jj_consume_token(1);
        break;
      case 2:
        jj_consume_token(2);
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        isNewLine = true;
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (CheckShowTablesNoTable())
    {
      ShowTablesNoTable();
    }
    else
    {
      ShowTables();
    }
    if (isNewLine)
    {
      System.out.print("SQL_2011-11693 > ");
    }
  }

  final public void DescQuery() throws ParseException {
  String tblName;
  boolean isNewLine = false;
    jj_consume_token(DESC);
    tblName = TableName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case 1:
    case 2:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 1:
        jj_consume_token(1);
        break;
      case 2:
        jj_consume_token(2);
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        isNewLine = true;
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (CheckNoSuchTable(tblName))
    {
      NoSuchTable();
    }
    else
    {
      Desc(tblName);
    }
    if (isNewLine)
    {
      System.out.print("SQL_2011-11693 > ");
    }
  }

  final public void SelectQuery() throws ParseException {
  boolean isNewLine = false;
  Vector < String > selCols;
    jj_consume_token(SELECT);
    selCols = SelectList();
    TableExpression(selCols);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case 1:
    case 2:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 1:
        jj_consume_token(1);
        break;
      case 2:
        jj_consume_token(2);
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        isNewLine = true;
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (isNewLine)
    {
      System.out.print("SQL_2011-11693 > ");
    }
  }

  final public Vector < String > SelectList() throws ParseException {
  String colName;
  Vector < String > colNames = new Vector < String > ();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 3:
      jj_consume_token(3);
    {if (true) return colNames;}
      break;
    case ALPHABET:
    case LEGAL_IDENTIFIER:
      colName = SelectedColumn();
      colNames.addElement(colName);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[23] = jj_gen;
          break label_4;
        }
        jj_consume_token(COMMA);
        colName = SelectedColumn();
        colNames.addElement(colName);
      }
      {if (true) return colNames;}
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String SelectedColumn() throws ParseException {
  String tblName = new String();
  String colName = new String();
    if (jj_2_2(2147483647)) {
      tblName = TableName();
      jj_consume_token(PERIOD);
      colName = ColumnName();
      {if (true) return tblName + "." + colName;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:
        colName = ColumnName();
      {if (true) return colName;}
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public void TableExpression(Vector < String > selectColumns) throws ParseException {
  Vector < String > fromTables;
  Vector < LogicValue > evalResult;
  String nonexistCol;
    if (jj_2_3(2147483647)) {
      fromTables = FromClause();
      evalResult = WhereClause(fromTables);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FROM:
        fromTables = FromClause();
        evalResult = new Vector < LogicValue > ();
        int joinedRecSize = GetJoinedRecords(fromTables).size() - 1;
        for (int i = 0; i < joinedRecSize; i++)
        {
          evalResult.addElement(LogicValue.T);
        }
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    if ((nonexistCol = CheckSelectColumnResolve(fromTables, selectColumns)) != null)
    {
      SelectColumnResolveError(nonexistCol);
    }
    Vector < Vector < String >> joinedRecords = GetJoinedRecords(fromTables);
    Vector < String > joinedColNames = joinedRecords.elementAt(0);
    Vector < Vector < String >> midResult = new Vector < Vector < String >> ();
    midResult.addElement(joinedColNames);
    for (int i = 1; i < joinedRecords.size(); i++)
    {
      Vector < String > recordAt = joinedRecords.elementAt(i);
      LogicValue eval = evalResult.elementAt(i - 1);
      if (eval == LogicValue.T)
      {
        midResult.addElement(recordAt);
      }
    }
    Vector < Vector < String >> finalResult = new Vector < Vector < String >> ();
    // * (select all)
    if (selectColumns.size() == 0)
    {
      finalResult = midResult;
      SelectPrint(finalResult, null);
    }
    else
    {
      Vector < String > tmp = new Vector < String > (selectColumns);
      // initialize
      for (int i = 0; i < midResult.size(); i++)
      {
        Vector < String > newVect = new Vector < String > ();
        finalResult.addElement(newVect);
      }
      for (int i = 0; i < selectColumns.size(); i++)
      {
        String selectColAt = selectColumns.elementAt(i);
        // if col form, change to tbl.col form
        if (!selectColAt.contains("."))
        {
          String tblName = new String();
          for (int j = 0; j < fromTables.size(); j++)
          {
            String fromTblAt = fromTables.elementAt(j);
            Vector < String > colsAt = GetAllColumns(fromTblAt);
            if (colsAt.contains(selectColAt))
            {
              tblName = fromTblAt;
            }
          }
          selectColAt = tblName + "." + selectColAt;
        }
        int selectColIdx = joinedColNames.indexOf(selectColAt);
        Vector < String > cols = finalResult.elementAt(0);
        cols.addElement(joinedColNames.elementAt(selectColIdx));
        for (int j = 1; j < finalResult.size(); j++)
        {
          Vector < String > recordAt = finalResult.elementAt(j);
          String val = midResult.elementAt(j).elementAt(selectColIdx);
          recordAt.addElement(val);
          finalResult.setElementAt(recordAt, j);
        }
      }
      SelectPrint(finalResult, tmp);
    }
  }

  final public Vector < String > FromClause() throws ParseException {
  Vector < String > tblNames;
  String nonexistTbl;
    jj_consume_token(FROM);
    tblNames = TableReferenceList();
    if ((nonexistTbl = CheckSelectTableExistence(tblNames)) != null)
    {
      SelectTableExistenceError(nonexistTbl);
    }
    {if (true) return tblNames;}
    throw new Error("Missing return statement in function");
  }

  final public Vector < String > TableReferenceList() throws ParseException {
  Vector < String > tblNames = new Vector < String > ();
  String tblName;
    tblName = ReferedTable();
    tblNames.addElement(tblName);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[27] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      tblName = ReferedTable();
      tblNames.addElement(tblName);
    }
    {if (true) return tblNames;}
    throw new Error("Missing return statement in function");
  }

  final public String ReferedTable() throws ParseException {
  String tblName;
    tblName = TableName();
    {if (true) return tblName;}
    throw new Error("Missing return statement in function");
  }

  final public Vector < LogicValue > WhereClause(Vector < String > tblNames) throws ParseException {
  Vector < LogicValue > result;
    jj_consume_token(WHERE);
    result = BooleanValueExpression(tblNames);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public Vector < LogicValue > BooleanValueExpression(Vector < String > tblNames) throws ParseException {
  Vector < LogicValue > l, r;
    l = BooleanTerm(tblNames);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_6;
      }
      jj_consume_token(OR);
      r = BooleanTerm(tblNames);
      // three-valued logic
      for (int i = 0; i < l.size(); i++)
      {
        LogicValue lAt = l.elementAt(i);
        LogicValue rAt = r.elementAt(i);
        if (lAt == LogicValue.T || rAt == LogicValue.T)
        {
          l.setElementAt(LogicValue.T, i);
        }
        else if (lAt == LogicValue.U || rAt == LogicValue.U)
        {
          l.setElementAt(LogicValue.U, i);
        }
        else
        {
          l.setElementAt(LogicValue.F, i);
        }
      }
    }
    {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final public Vector < LogicValue > BooleanTerm(Vector < String > tblNames) throws ParseException {
  Vector < LogicValue > l, r;
    l = BooleanFactor(tblNames);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_7;
      }
      jj_consume_token(AND);
      r = BooleanFactor(tblNames);
      // three-valued logic
      for (int i = 0; i < l.size(); i++)
      {
        LogicValue lAt = l.elementAt(i);
        LogicValue rAt = r.elementAt(i);
        if (lAt == LogicValue.F || rAt == LogicValue.F)
        {
          l.setElementAt(LogicValue.F, i);
        }
        else if (lAt == LogicValue.U || rAt == LogicValue.U)
        {
          l.setElementAt(LogicValue.U, i);
        }
        else
        {
          l.setElementAt(LogicValue.T, i);
        }
      }
    }
    {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final public Vector < LogicValue > BooleanFactor(Vector < String > tblNames) throws ParseException {
  Vector < LogicValue > l;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_PAREN:
    case DIGIT:
    case ALPHABET:
    case LEGAL_IDENTIFIER:
    case INT_VALUE:
    case DATE_VALUE:
    case CHAR_STRING:
      l = BooleanTest(tblNames);
      break;
    case NOT:
      jj_consume_token(NOT);
      l = BooleanTest(tblNames);
        // three-valued logic
        for (int i = 0; i < l.size(); i++)
        {
          LogicValue lAt = l.elementAt(i);
          if (lAt == LogicValue.T)
          {
            l.setElementAt(LogicValue.F, i);
          }
          else if (lAt == LogicValue.F)
          {
            l.setElementAt(LogicValue.T, i);
          }
        }
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final public Vector < LogicValue > BooleanTest(Vector < String > tblNames) throws ParseException {
  Vector < LogicValue > l;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIGIT:
    case ALPHABET:
    case LEGAL_IDENTIFIER:
    case INT_VALUE:
    case DATE_VALUE:
    case CHAR_STRING:
      l = Predicate(tblNames);
      break;
    case LEFT_PAREN:
      l = ParentehsizedBooleanExpression(tblNames);
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final public Vector < LogicValue > ParentehsizedBooleanExpression(Vector < String > tblNames) throws ParseException {
  Vector < LogicValue > l;
    jj_consume_token(LEFT_PAREN);
    l = BooleanValueExpression(tblNames);
    jj_consume_token(RIGHT_PAREN);
    {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final public Vector < LogicValue > Predicate(Vector < String > tblNames) throws ParseException {
  Vector < LogicValue > l;
    if (jj_2_4(2147483647)) {
      l = ComparisonPredicate(tblNames);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:
        l = NullPredicate(tblNames);
        break;
      default:
        jj_la1[32] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final public Vector < LogicValue > ComparisonPredicate(Vector < String > tblNames) throws ParseException {
  Vector < LogicValue > result = new Vector < LogicValue > ();
  String l, r, op;
    l = CompOperand(tblNames);
    op = jj_consume_token(COMP_OP).image;
    r = CompOperand(tblNames);
    Vector < Vector < String >> allRecords = GetJoinedRecords(tblNames);
    Vector < String > colNames = allRecords.elementAt(0);
    for (int i = 1; i < allRecords.size(); i++)
    {
      Vector < String > recordAt = allRecords.elementAt(i);
      LogicValue logicVal;
      String left, right;
      boolean bool = false, isUnknown = false;
      // if operand is column name
      if (!CheckInteger(l) && !CheckString(l) && !CheckDate(l))
      {
        // tbl.col form
        if (l.contains("."))
        {
          int idx = colNames.indexOf(l);
          left = recordAt.elementAt(idx);
        }
        // col form
        else
        {
          int idx = - 1;
          for (int j = 0; j < colNames.size(); j++)
          {
            String tblColAt = colNames.elementAt(j);
            StringTokenizer st = new StringTokenizer(tblColAt, ".");
            st.nextToken();
            String colAt = st.nextToken();
            if (colAt.equals(l))
            {
              idx = j;
              break;
            }
          }
          left = recordAt.elementAt(idx);
        }
      }
      else
      {
        left = l;
      }
      // if operand is column name
      if (!CheckInteger(r) && !CheckString(r) && !CheckDate(r))
      {
        // tbl.col form
        if (r.contains("."))
        {
          int idx = colNames.indexOf(r);
          right = recordAt.elementAt(idx);
        }
        // col form
        else
        {
          int idx = - 1;
          for (int j = 0; j < colNames.size(); j++)
          {
            String tblColAt = colNames.elementAt(j);
            StringTokenizer st = new StringTokenizer(tblColAt, ".");
            st.nextToken();
            String colAt = st.nextToken();
            if (colAt.equals(r))
            {
              idx = j;
              break;
            }
          }
          right = recordAt.elementAt(idx);
        }
      }
      else
      {
        right = r;
      }
      // if two are integers
      if (CheckInteger(left) && CheckInteger(right))
      {
        int lhs = Integer.parseInt(left);
        int rhs = Integer.parseInt(right);
        if (op.equals("<"))
        {
          bool = lhs < rhs;
        }
        else if (op.equals(">"))
        {
          bool = lhs > rhs;
        }
        else if (op.equals("="))
        {
          bool = lhs == rhs;
        }
        else if (op.equals("<="))
        {
          bool = lhs <= rhs;
        }
        else if (op.equals(">="))
        {
          bool = lhs >= rhs;
        }
        else if (op.equals("!="))
        {
          bool = lhs != rhs;
        }
      }
      // if two are char or date
      else if ((CheckString(left) && CheckString(right)) || (CheckDate(left) && CheckDate(right)))
      {
        String lhs = left;
        String rhs = right;
        if (op.equals("<"))
        {
          bool = lhs.compareTo(rhs) < 0;
        }
        else if (op.equals(">"))
        {
          bool = lhs.compareTo(rhs) > 0;
        }
        else if (op.equals("="))
        {
          bool = lhs.compareTo(rhs) == 0;
        }
        else if (op.equals("<="))
        {
          bool = lhs.compareTo(rhs) <= 0;
        }
        else if (op.equals(">="))
        {
          bool = lhs.compareTo(rhs) >= 0;
        }
        else if (op.equals("!="))
        {
          bool = lhs.compareTo(rhs) != 0;
        }
      }
      // if compared to null value
      else if (left.equals("null") || right.equals("null"))
      {
        isUnknown = true;
      }
      // incomparable
      else
      {
        WhereIncomparableError();
      }
      if (isUnknown)
      {
        logicVal = LogicValue.U;
      }
      else if (bool)
      {
        logicVal = LogicValue.T;
      }
      else
      {
        logicVal = LogicValue.F;
      }
      result.addElement(logicVal);
    }
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public String CompOperand(Vector < String > tblNames) throws ParseException {
  String tblName, colName, val;
    if (jj_2_5(2147483647)) {
      tblName = TableName();
      jj_consume_token(PERIOD);
      colName = ColumnName();
        if (!tblNames.contains(tblName))
        {
          WhereTableNotSpecified();
        }
        else if (!GetAllColumns(tblName).contains(colName))
        {
          WhereColumnNotExist();
        }
        {if (true) return tblName + "." + colName;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:
        colName = ColumnName();
        int cnt = 0;
        for (int i = 0; i < tblNames.size(); i++)
        {
          String tblNameAt = tblNames.elementAt(i);
          Vector < String > colsAt = GetAllColumns(tblNameAt);
          if (colsAt.contains(colName))
          {
            cnt++;
          }
        }
        if (cnt == 0)
        {
          WhereColumnNotExist();
        }
        else if (cnt > 1)
        {
          WhereAmbiguousReference();
        }
        {if (true) return colName;}
        break;
      case DIGIT:
      case INT_VALUE:
      case DATE_VALUE:
      case CHAR_STRING:
        val = ComparableValue();
        {if (true) return val;}
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public String ComparableValue() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DATE_VALUE:
      t = jj_consume_token(DATE_VALUE);
      break;
    case INT_VALUE:
      t = jj_consume_token(INT_VALUE);
      break;
    case DIGIT:
      t = jj_consume_token(DIGIT);
      break;
    case CHAR_STRING:
      t = jj_consume_token(CHAR_STRING);
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public Vector < LogicValue > NullPredicate(Vector < String > tblNames) throws ParseException {
  Vector < LogicValue > result = new Vector < LogicValue > ();
  String tblName = null, colName, nullOp;
    Vector < Vector < String >> allRecords = GetJoinedRecords(tblNames);
    Vector < String > colNames = allRecords.elementAt(0);
    if (jj_2_6(2147483647)) {
      tblName = TableName();
      jj_consume_token(PERIOD);
      colName = ColumnName();
      nullOp = NullOperation();
        if (!tblNames.contains(tblName))
        {
          WhereTableNotSpecified();
        }
        Vector < String > cols = GetAllColumns(tblName);
        if (!cols.contains(colName))
        {
          WhereColumnNotExist();
        }
        int colIdx = GetColumnIndex(tblName, colName);
        for (int i = 1; i < allRecords.size(); i++)
        {
          Vector < String > recordAt = allRecords.elementAt(i);
          String valAt = recordAt.elementAt(colIdx);
          if ((valAt.equals("null") && nullOp.equals("is null")) || (!valAt.equals("null") && nullOp.equals("is not null")))
          {
            result.addElement(LogicValue.T);
          }
          else if ((valAt.equals("null") && nullOp.equals("is not null")) || (!valAt.equals("null") && nullOp.equals("is null")))
          {
            result.addElement(LogicValue.F);
          }
        }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:
        colName = ColumnName();
        nullOp = NullOperation();
        int cnt = 0;
        String matchTbl = new String();
        for (int i = 0; i < tblNames.size(); i++)
        {
          String tblNameAt = tblNames.elementAt(i);
          Vector < String > colsAt = GetAllColumns(tblNameAt);
          if (colsAt.contains(colName))
          {
            matchTbl = tblNameAt;
            cnt++;
          }
        }
        if (cnt == 0)
        {
          WhereColumnNotExist();
        }
        else if (cnt > 1)
        {
          WhereAmbiguousReference();
        }
        int colIdx = GetColumnIndex(matchTbl, colName);
        for (int i = 1; i < allRecords.size(); i++)
        {
          Vector < String > recordAt = allRecords.elementAt(i);
          String valAt = recordAt.elementAt(colIdx);
          if ((valAt.equals("null") && nullOp.equals("is null")) || (!valAt.equals("null") && nullOp.equals("is not null")))
          {
            result.addElement(LogicValue.T);
          }
          else if ((valAt.equals("null") && nullOp.equals("is not null")) || (!valAt.equals("null") && nullOp.equals("is null")))
          {
            result.addElement(LogicValue.F);
          }
        }
        break;
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public String NullOperation() throws ParseException {
  String nullOp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IS_NULL:
      nullOp = jj_consume_token(IS_NULL).image;
      break;
    case IS_NOT_NULL:
      nullOp = jj_consume_token(IS_NOT_NULL).image;
      break;
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return nullOp;}
    throw new Error("Missing return statement in function");
  }

  final public void InsertQuery() throws ParseException {
  String tblName;
  boolean isNewLine = false;
    jj_consume_token(INSERT_INTO);
    tblName = TableName();
    if (CheckNoSuchTable(tblName))
    {
      NoSuchTable();
    }
    InsertColumnsAndSource(tblName);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case 1:
    case 2:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 1:
        jj_consume_token(1);
        break;
      case 2:
        jj_consume_token(2);
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        isNewLine = true;
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    InsertResult();
    if (isNewLine)
    {
      System.out.print("SQL_2011-11693 > ");
    }
  }

  final public void InsertColumnsAndSource(String tblName) throws ParseException {
  String colName;
  Vector < String > cols = new Vector < String > ();
  Vector < String > values;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_PAREN:
      cols = ColumnNameListInsert();
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
    values = ValueList();
    if ((colName = CheckInsertColumnExistence(tblName, cols)) != null)
    {
      InsertColumnExistenceError(colName);
    }
    else if (CheckInsertDuplicateColumn(cols))
    {
      InsertDuplicateColumnError();
    }
    CheckInsertColumnNonNullableAndTypeMismatch(tblName, cols, values);
    if (CheckInsertDuplicatePrimaryKey(tblName, cols, values))
    {
      InsertDuplicatePrimaryKeyError();
    }
    else if (CheckInsertReferentialIntegrity(tblName, cols, values))
    {
      InsertReferentialIntegrityError();
    }
    // insert values into DB
    InsertValues(tblName, cols, values);
  }

  final public Vector < String > ColumnNameListInsert() throws ParseException {
  String colName;
  Vector < String > cols;
    cols = new Vector < String > ();
    jj_consume_token(LEFT_PAREN);
    colName = ColumnName();
    cols.addElement(colName);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[40] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
      colName = ColumnName();
      cols.addElement(colName);
    }
    jj_consume_token(RIGHT_PAREN);
    {if (true) return cols;}
    throw new Error("Missing return statement in function");
  }

  final public Vector < String > ValueList() throws ParseException {
  String val;
  Vector < String > values;
    values = new Vector < String > ();
    jj_consume_token(VALUES);
    jj_consume_token(LEFT_PAREN);
    val = Value();
    values.addElement(val);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[41] = jj_gen;
        break label_9;
      }
      jj_consume_token(COMMA);
      val = Value();
      values.addElement(val);
    }
    jj_consume_token(RIGHT_PAREN);
    {if (true) return values;}
    throw new Error("Missing return statement in function");
  }

  final public String Value() throws ParseException {
  Token t;
  String val;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULL:
      t = jj_consume_token(NULL);
    {if (true) return t.image;}
      break;
    case DIGIT:
    case INT_VALUE:
    case DATE_VALUE:
    case CHAR_STRING:
      val = ComparableValue();
      {if (true) return val;}
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void DeleteQuery() throws ParseException {
  boolean isNewLine = false;
  String tblName;
  Vector < String > tblNames = new Vector < String > ();
  Vector < LogicValue > eval = new Vector < LogicValue > ();
  Vector < String > result = new Vector < String > ();
    jj_consume_token(DELETE_FROM);
    tblName = TableName();
    if (CheckNoSuchTable(tblName))
    {
      NoSuchTable();
    }
    tblNames.addElement(tblName);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      eval = WhereClause(tblNames);
      break;
    default:
      jj_la1[43] = jj_gen;
      ;
    }
    // if there is no where clause
    if (eval.size() == 0)
    {
      int recordSize = myDB.getDB(tblName + " @record").size();
      for (int i = 0; i < recordSize; i++)
      {
        eval.addElement(LogicValue.T);
      }
    }
    CascadeDelete(tblName, eval);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case 1:
    case 2:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 1:
        jj_consume_token(1);
        break;
      case 2:
        jj_consume_token(2);
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        isNewLine = true;
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (isNewLine)
    {
      System.out.print("SQL_2011-11693 > ");
    }
  }

  final public void Start() throws ParseException {
  Token t;
    System.out.print("SQL_2011-11693 > ");
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXIT:
      case CREATE_TABLE:
      case DROP_TABLE:
      case SHOW_TABLES:
      case DESC:
      case SELECT:
      case INSERT_INTO:
      case DELETE_FROM:
        ;
        break;
      default:
        jj_la1[46] = jj_gen;
        break label_10;
      }
      Command();
    }
    System.out.println("Syntax error");
    parser = new EG1(System.in);
    handleSyntaxError(parser);
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_3_6() {
    if (jj_3R_13()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_23()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_17() {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_17()) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) return true;
    }
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_3R_13()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_11()) return true;
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_39() {
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3R_38() {
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3R_44() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) return true;
    }
    return false;
  }

  private boolean jj_3R_37() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) return true;
    }
    return false;
  }

  private boolean jj_3R_28() {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_27()) return true;
    return false;
  }

  private boolean jj_3R_23() {
    if (jj_3R_27()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_28()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_21() {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_47() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) return true;
    }
    return false;
  }

  private boolean jj_3R_13() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_21()) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) return true;
    }
    return false;
  }

  private boolean jj_3R_15() {
    if (jj_scan_token(WHERE)) return true;
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(15)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_11()) return true;
    if (jj_3R_12()) return true;
    if (jj_scan_token(NOT_NULL)) return true;
    return false;
  }

  private boolean jj_3R_20() {
    if (jj_scan_token(DATE)) return true;
    return false;
  }

  private boolean jj_3R_36() {
    if (jj_scan_token(NOT)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3R_25() {
    if (jj_3R_13()) return true;
    return false;
  }

  private boolean jj_3R_35() {
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3R_31() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) return true;
    }
    return false;
  }

  private boolean jj_3R_19() {
    if (jj_scan_token(CHAR)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(15)) return true;
    }
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_18() {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  private boolean jj_3R_12() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_18()) {
    jj_scanpos = xsp;
    if (jj_3R_19()) {
    jj_scanpos = xsp;
    if (jj_3R_20()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_26() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3R_22() {
    if (jj_3R_25()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_26()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_14()) return true;
    if (jj_3R_15()) return true;
    return false;
  }

  private boolean jj_3R_16() {
    if (jj_3R_24()) return true;
    if (jj_scan_token(COMP_OP)) return true;
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3R_30() {
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_16()) return true;
    return false;
  }

  private boolean jj_3R_46() {
    if (jj_3R_11()) return true;
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_13()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3R_33() {
    if (jj_scan_token(AND)) return true;
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_43() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_14() {
    if (jj_scan_token(FROM)) return true;
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3R_42() {
    if (jj_3R_16()) return true;
    return false;
  }

  private boolean jj_3R_27() {
    if (jj_3R_32()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_33()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_40() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) return true;
    }
    return false;
  }

  private boolean jj_3R_29() {
    if (jj_3R_13()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3R_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_29()) {
    jj_scanpos = xsp;
    if (jj_3R_30()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_13()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public EG1TokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[47];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x80c00000,0x80c00000,0x6,0x106,0x6,0x106,0x1000,0x6080000,0x80000,0x6000000,0x1000,0x8000,0x70000000,0x80000,0x80000,0x6,0x106,0x6,0x106,0x6,0x106,0x6,0x106,0x1000,0x80008,0x80000,0x0,0x1000,0x0,0x0,0x88400,0x88400,0x80000,0x88000,0x8000,0x80000,0x0,0x6,0x106,0x400,0x1000,0x1000,0x8000,0x0,0x6,0x106,0x80c00000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x4807,0x4807,0x0,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0x0,0x10000,0x0,0x8000,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x8000,0x10,0x0,0x80,0x40,0x78100,0x78000,0x8000,0x78000,0x70000,0x8000,0x600,0x0,0x0,0x0,0x0,0x0,0x72000,0x20,0x0,0x0,0x4807,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[6];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public EG1(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public EG1(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new EG1TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 47; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 47; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public EG1(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new EG1TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 47; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 47; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public EG1(EG1TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 47; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(EG1TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 47; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[51];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 47; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 51; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 6; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}

class myDatabase
{
  static Environment myDBEnvironment = null;
  static Database myDatabase = null;
  static Cursor myDBCursor = null;

  public static void openDB()
  {
    EnvironmentConfig envConfig = new EnvironmentConfig();
    envConfig.setAllowCreate(true);
    myDBEnvironment = new Environment(new File("db/"), envConfig);
    DatabaseConfig dbConfig = new DatabaseConfig();
    dbConfig.setAllowCreate(true);
    dbConfig.setSortedDuplicates(true);
    myDatabase = myDBEnvironment.openDatabase(null, "myDatabase", dbConfig);
    myDBCursor = myDatabase.openCursor(null, null);
  }

  public static void closeDB()
  {
    if (myDBCursor != null) myDBCursor.close();
    if (myDatabase != null) myDatabase.close();
    if (myDBEnvironment != null) myDBEnvironment.close();
  }

  public static void putDB(String key, String value)
  {
    DatabaseEntry _key;
    DatabaseEntry _value;
    try
    {
      _key = new DatabaseEntry(key.getBytes("UTF-8"));
      _value = new DatabaseEntry(value.getBytes("UTF-8"));
      myDBCursor.put(_key, _value);
    }
    catch (DatabaseException de)
    {}
    catch (UnsupportedEncodingException e)
    {
      e.printStackTrace();
    }
  }

  public static Vector<String> getDB(String key)
  {
    Vector<String> valueSet = new Vector<String>();
    Cursor cursor = null;
    try
    {
      DatabaseEntry foundKey = new DatabaseEntry(key.getBytes("UTF-8"));
      DatabaseEntry foundValue = new DatabaseEntry();
      cursor = myDatabase.openCursor(null, null);
      OperationStatus retVal = cursor.getSearchKey(foundKey, foundValue, LockMode.DEFAULT);
      while (retVal == OperationStatus.SUCCESS)
      {
        String valueString = new String(foundValue.getData(), "UTF-8");
        valueSet.addElement(valueString);
        retVal = cursor.getNextDup(foundKey, foundValue, LockMode.DEFAULT);
      }
    }
    catch (Exception e)
    {}
    finally
    {
      cursor.close();
    }
    return valueSet;
  }

  public static void deleteDB(String key)
  {
    try
    {
      DatabaseEntry theKey = new DatabaseEntry(key.getBytes("UTF-8"));
      myDatabase.delete(null, theKey);
    }
    catch (Exception e)
    {}
  }

  // For debugging
  public static void printDB()
  {
    Cursor cursor = null;
    try
    {
      DatabaseEntry foundKey = new DatabaseEntry();
      DatabaseEntry foundData = new DatabaseEntry();
      cursor = myDatabase.openCursor(null, null);
      cursor.getFirst(foundKey, foundData, LockMode.DEFAULT);
      do
      {
        String keyString = new String(foundKey.getData(), "UTF-8");
        String dataString = new String(foundData.getData(), "UTF-8");
        System.out.println("<" + keyString + ", " + dataString + ">");
      }
      while (cursor.getNext(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.SUCCESS);
    }
    catch (Exception e)
    {}
    finally
    {
      cursor.close();
    }
  }

  // For DB error handling and drop table query
  public static void deleteTable(String tblName)
  {
    Cursor cursor = null;
    try
    {
      DatabaseEntry colDef = new DatabaseEntry((tblName + " @column definition").getBytes("UTF-8"));
      DatabaseEntry priKey = new DatabaseEntry((tblName + " @primary key").getBytes("UTF-8"));
      DatabaseEntry forKey = new DatabaseEntry((tblName + " @foreign key").getBytes("UTF-8"));
      DatabaseEntry records = new DatabaseEntry((tblName + " @record").getBytes("UTF-8"));
      myDatabase.delete(null, colDef);
      myDatabase.delete(null, priKey);
      myDatabase.delete(null, forKey);
      myDatabase.delete(null, records);
    }
    catch (Exception e)
    {}
  }
}
