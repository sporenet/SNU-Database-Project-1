/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  static = false;
  DEBUG_PARSER = false;
}

PARSER_BEGIN(EG1)

import java.util.Set;
import java.util.HashSet;
import java.util.Arrays;
import java.util.Vector;
import java.util.StringTokenizer;
import java.util.HashMap;
import java.util.Iterator;
import java.io.File;
import java.io.UnsupportedEncodingException;

import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.Cursor;

import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;

import com.sleepycat.je.LockMode;
import com.sleepycat.je.OperationStatus;

enum LogicValue
{
    T, F, U
};

public class EG1
{
  // enumeration of three-valued logic
  
  
  static final String [] keywordList = new String []
  {
    "exit",
    "create",
    "table",
    "not",
    "null",
    "primary",
    "key",
    "foreign",
    "references",
    "int",
    "char",
    "date",
    "drop",
    "show",
    "tables",
    "desc",
    "select",
    "as",
    "from",
    "where",
    "and",
    "or",
    "is",
    "insert",
    "into",
    "values",
    "delete"
  };

  static final Set<String> keywordSet = new HashSet<String> (Arrays.asList(keywordList));
  static myDatabase myDB = new myDatabase();
  static EG1 parser;
  static String tmpColDef = "";
  static String tmpPriKey = "";
  static String tmpForKey = "";
  static String delim = "|";
  static String createTblName = "";
  static String dropTblName = "";
  static Vector<String > tblNameList = new Vector<String >();

  public static void main(String args []) throws ParseException
  {
    myDB.openDB();
    parser = new EG1(System.in);
    tblNameList = myDB.getDB("@table name");
    handleSyntaxError(parser);
  }

  public static void handleSyntaxError(EG1 parser)
  {
    try
    {
      parser.Start();
    }
    catch (ParseException e)
    {
      System.out.println("Syntax error");
      myDB.deleteTable(createTblName);
      parser = new EG1(System.in);
      handleSyntaxError(parser);
    }
  }

  public static void handleDBError(EG1 parser)  {    parser = new EG1(System.in);    handleSyntaxError(parser);  }
}

class myDatabase{  static Environment myDBEnvironment = null;  static Database myDatabase = null;  static Cursor myDBCursor = null;  public static void openDB()  {    EnvironmentConfig envConfig = new EnvironmentConfig();    envConfig.setAllowCreate(true);    myDBEnvironment = new Environment(new File("db/"), envConfig);    DatabaseConfig dbConfig = new DatabaseConfig();    dbConfig.setAllowCreate(true);    dbConfig.setSortedDuplicates(true);    myDatabase = myDBEnvironment.openDatabase(null, "myDatabase", dbConfig);    myDBCursor = myDatabase.openCursor(null, null);  }  public static void closeDB()  {    if (myDBCursor != null) myDBCursor.close();    if (myDatabase != null) myDatabase.close();    if (myDBEnvironment != null) myDBEnvironment.close();  }  public static void putDB(String key, String value)  {    DatabaseEntry _key;    DatabaseEntry _value;    try    {      _key = new DatabaseEntry(key.getBytes("UTF-8"));      _value = new DatabaseEntry(value.getBytes("UTF-8"));      myDBCursor.put(_key, _value);    }    catch (DatabaseException de)    {}    catch (UnsupportedEncodingException e)    {      e.printStackTrace();    }  }  public static Vector<String> getDB(String key)  {    Vector<String> valueSet = new Vector<String>();    Cursor cursor = null;    try    {      DatabaseEntry foundKey = new DatabaseEntry(key.getBytes("UTF-8"));      DatabaseEntry foundValue = new DatabaseEntry();      cursor = myDatabase.openCursor(null, null);      OperationStatus retVal = cursor.getSearchKey(foundKey, foundValue, LockMode.DEFAULT);      while (retVal == OperationStatus.SUCCESS)      {        String valueString = new String(foundValue.getData(), "UTF-8");        valueSet.addElement(valueString);        retVal = cursor.getNextDup(foundKey, foundValue, LockMode.DEFAULT);      }    }    catch (Exception e)    {}    finally    {      cursor.close();    }    return valueSet;  }  public static void deleteDB(String key)  {    try    {      DatabaseEntry theKey = new DatabaseEntry(key.getBytes("UTF-8"));      myDatabase.delete(null, theKey);    }    catch (Exception e)    {}  }  // For debugging
  public static void printDB()  {    Cursor cursor = null;    try    {      DatabaseEntry foundKey = new DatabaseEntry();      DatabaseEntry foundData = new DatabaseEntry();      cursor = myDatabase.openCursor(null, null);      cursor.getFirst(foundKey, foundData, LockMode.DEFAULT);      do      {        String keyString = new String(foundKey.getData(), "UTF-8");        String dataString = new String(foundData.getData(), "UTF-8");        System.out.println("<" + keyString + ", " + dataString + ">");      }      while (cursor.getNext(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.SUCCESS);    }    catch (Exception e)    {}    finally    {      cursor.close();    }  }  // For DB error handling and drop table query
  public static void deleteTable(String tblName)  {    Cursor cursor = null;    try    {      DatabaseEntry colDef = new DatabaseEntry((tblName + " @column definition").getBytes("UTF-8"));      DatabaseEntry priKey = new DatabaseEntry((tblName + " @primary key").getBytes("UTF-8"));      DatabaseEntry forKey = new DatabaseEntry((tblName + " @foreign key").getBytes("UTF-8"));      DatabaseEntry records = new DatabaseEntry((tblName + " @record").getBytes("UTF-8"));      myDatabase.delete(null, colDef);      myDatabase.delete(null, priKey);      myDatabase.delete(null, forKey);      myDatabase.delete(null, records);    }    catch (Exception e)    {}  }}PARSER_END(EG1)// Messages
void DuplicateColumnDefError(String tblName) :{}{  {    System.out.println("Create table has failed: column definition is duplicated");    myDB.deleteTable(tblName);    handleDBError(parser);  }}void TableExistenceError() :{}{  {    System.out.println("Create table has failed: table with the same name already exist");    handleDBError(parser);  }}void CharLengthError() :{}{  {    System.out.println("Char length should be > 0");    handleDBError(parser);  }}void DuplicatePrimaryKeyDefError(String tblName) :{}{  {    System.out.println("Create table has failed: primary key definition is duplicated");    myDB.deleteTable(tblName);    handleDBError(parser);  }}void NonExistingColumnDefError(String tblName, String colName) :{}{  {    System.out.println("Create table has failed: '" + colName + "' does not exists in column definition");    myDB.deleteTable(tblName);    handleDBError(parser);  }}void ReferenceTableExistenceError(String tblName) :{}{  {    System.out.println("Create table has failed: foreign key references non existing table");    myDB.deleteTable(tblName);    handleDBError(parser);  }}void ReferenceNonPrimaryKeyError(String tblName) :{}{  {    System.out.println("Create table has failed: foreign key references non primary key column");    myDB.deleteTable(tblName);    handleDBError(parser);  }}void ReferenceColumnExistenceError(String tblName) :{}{  {    System.out.println("Create table has failed: foreign key references non existing column");    myDB.deleteTable(tblName);    handleDBError(parser);  }}void ReferenceTypeError(String tblName) :{}{  {    System.out.println("Create table has failed: foreign key references wrong type");    myDB.deleteTable(tblName);    handleDBError(parser);  }}void NoSuchTable() :{}{  {    System.out.println("No such table");    handleDBError(parser);  }}void DropReferencedTableError(String tblName) :{}{  {    System.out.println("Drop table has failed: '" + tblName + "' is referenced by other table");    handleDBError(parser);  }}void ShowTablesNoTable() :{}{  {    System.out.println("There is no table");    handleDBError(parser);  }}void InvalidDateRangeError() :{}{  {    System.out.println("Date value is in incorrect range");    handleDBError(parser);  }}void InsertColumnExistenceError(String colName) :{}{  {    System.out.println("Insertion has failed: '" + colName + "' does not exist");    handleDBError(parser);  }}void InsertDuplicateColumnError() :{}{  {    System.out.println("Insertion has failed: Column is duplicated");    handleDBError(parser);  }}void InsertColumnNonNullableError(String colName) :{}{  {    System.out.println("Insertion has failed: '" + colName + "' is not nullable");    handleDBError(parser);  }}void InsertTypeMismatchError() :{}{  {    System.out.println("Insertion has failed: Types are not matched");    handleDBError(parser);  }}void InsertDuplicatePrimaryKeyError() :{}{  {    System.out.println("Insertion has failed: Primary key duplication");    handleDBError(parser);  }}void InsertReferentialIntegrityError() :{}{  {    System.out.println("Insertion has failed: Referential integrity violation");    handleDBError(parser);  }}void WhereIncomparableError() :{}{  {    System.out.println("Where clause try to compare incomparable values");    handleDBError(parser);  }}void WhereTableNotSpecified() :{}{  {    System.out.println("Where clause try to reference tables which are not specified");    handleDBError(parser);  }}void WhereColumnNotExist() :{}{  {    System.out.println("Where clause try to reference non existing column");    handleDBError(parser);  }}void WhereAmbiguousReference() :{}{  {    System.out.println("Where clause contains ambiguous reference");    handleDBError(parser);  }}void SelectTableExistenceError(String tblName) :{}{  {    System.out.println("Selection has failed: '" + tblName + "' does not exist");    handleDBError(parser);  }}void SelectColumnResolveError(String colName) :{}{  {    System.out.println("Selection has failed: failed to resolve '" + colName + "'");    handleDBError(parser);  }}void CreateTableSuccess() :{}{  {    System.out.println("'" + createTblName + "' table is created");  }}void DropSuccess() :{}{  {    System.out.println("'" + dropTblName + "' table is dropped");  }}void InsertResult() :{}{  {    System.out.println("The row is inserted");  }}void DeleteResult(int count) :{}{  {    System.out.printf("%d %s\n", count, "row(s) are deleted");  }}void DeleteReferentialIntegrityPassed(int count) :{}{  {    System.out.printf("%d %s\n", count, "row(s) are not deleted due to referential integrity");  }}// Checking Functions
// Get column definition from DB and check duplicate columns
boolean CheckDuplicateColumnDef(String tblName) :{}{  {    Vector < String > colNames = GetAllColumns(tblName);    for (int i = 0; i < colNames.size() - 1; i++)    {      for (int j = i + 1; j < colNames.size(); j++)      {        if (colNames.elementAt(i).equals(colNames.elementAt(j)))        {          return true;        }      }    }    return false;  }}// Get table names from DB and check whether input table name exists in DBboolean CheckTableExistence(String tblName) :{}{  {    Vector < String > tables = myDB.getDB("@table name");    return tables.contains(tblName);  }}// Get primary key definition from this table and check whether it occurs more than one timesboolean CheckDuplicatePrimaryKeyDef(String tblName) :{}{  {    Vector < String > priKeys = myDB.getDB(tblName + " @primary key");    return priKeys.size() > 1;  }}// Get primary key and foreign key definition from this table and check whether column names of this definition didn't occur in DBString CheckNonExistingColumnDef(String tblName) :{}{  {    Vector < String > forKeys = myDB.getDB(tblName + " @foreign key");    Vector < String > colNames = GetAllColumns(tblName);    Vector < String > priKeyCols = GetPrimaryKeyColumns(tblName);    // Check primary key definition
    for (int i = 0; i < priKeyCols.size(); i++)    {      String priKeyColAt = priKeyCols.elementAt(i);      if (!colNames.contains(priKeyColAt))      {        return priKeyColAt;      }    }    // Check foreign key definition
    for (int i = 0; i < forKeys.size(); i++)    {      String forKeyDef = forKeys.elementAt(i);      StringTokenizer st3 = new StringTokenizer(forKeyDef, delim);      while (st3.hasMoreTokens())      {        String colName = st3.nextToken();        if (colName.contains("references"))        {          break;        }        else if (!colNames.contains(colName))        {          return colName;        }      }    }    return null;  }}// Get referenced table names from this table and check whether those referenced tables are really existboolean CheckReferenceTableExistence(String tblName) :{}{  {    Vector < String > tblNames = myDB.getDB("@table name");    Vector < String > refTblNames = GetReferenceTables(tblName);    for (int i = 0; i < refTblNames.size(); i++)    {      String refTblNameAt = refTblNames.elementAt(i);      if (!tblNames.contains(refTblNameAt))      {        return true;      }    }    return false;  }}// Get referenced columns from this table and check whether these columns are not primary key of referenced tableboolean CheckReferenceNonPrimaryKey(String tblName) :{}{  {    Vector < String > forKeys = myDB.getDB(tblName + " @foreign key");    String refTblName = "";    for (int i = 0; i < forKeys.size(); i++)    {      // Get referenced columns      String forKeyDef = forKeys.elementAt(i);      StringTokenizer st = new StringTokenizer(forKeyDef, delim);      Vector < String > refCols = new Vector < String > ();      boolean isRefCol = false;      while (st.hasMoreTokens())      {        String tmpstr = st.nextToken();        if (tmpstr.contains("references"))        {          refTblName = tmpstr.substring(12);          isRefCol = true;          continue;        }        else if (isRefCol)        {          String refColName = tmpstr;          refCols.addElement(refColName);        }      }      Vector < String > refPriKeyCols = GetPrimaryKeyColumns(refTblName);      // Check whether all of referenced columns are primary key      if (!refPriKeyCols.equals(refCols))      {        return true;      }    }    return false;  }}// Get referenced columns from this table and check whether these columns are really exist in referenced tableboolean CheckReferenceColumnExistence(String tblName) :{}{  {    Vector < String > forKeys = myDB.getDB(tblName + " @foreign key");    String refTblName = "";    for (int i = 0; i < forKeys.size(); i++)    {      // Get referenced columns      String forKeyDef = forKeys.elementAt(i);      StringTokenizer st = new StringTokenizer(forKeyDef, delim);      Vector < String > refCols = new Vector < String > ();      boolean isRefCol = false;      while (st.hasMoreTokens())      {        String tmpstr = st.nextToken();        if (tmpstr.contains("references"))        {          refTblName = tmpstr.substring(12);          isRefCol = true;          continue;        }        else if (isRefCol)        {          String refColName = tmpstr;          refCols.addElement(refColName);        }      }      Vector < String > refRealColNames = GetAllColumns(refTblName);      // Check whether all of referenced columns exist in referenced table      for (int j = 0; j < refCols.size(); j++)      {        if (!refRealColNames.contains(refCols.elementAt(j)))        {          return true;        }      }    }    return false;  }}// Get type of referenced columns and referencing columns and check whether types of both columns are sameboolean CheckReferenceType(String tblName) :{}{  {    Vector < String > forKeys = myDB.getDB(tblName + " @foreign key");    for (int i = 0; i < forKeys.size(); i++)    {      // Get referenced columns and referencing columns      String forKeyDef = forKeys.elementAt(i);      StringTokenizer st = new StringTokenizer(forKeyDef, delim);      Vector < String > forCols = new Vector < String > ();      Vector < String > refCols = new Vector < String > ();      String refTblName = "";      boolean isRefCol = false;      while (st.hasMoreTokens())      {        String tmpstr = st.nextToken();        if (tmpstr.contains("references"))        {          refTblName = tmpstr.substring(12);          isRefCol = true;          continue;        }        else if (isRefCol)        {          String refColName = tmpstr;          refCols.addElement(refColName);        }        else        {          String forColName = tmpstr;          forCols.addElement(forColName);        }      }      // If number of referenced columns and referencing columns are different, type error      if (refCols.size() != forCols.size())      {        return true;      }      // Check type of these columns one by one      else      {        for (int j = 0; j < refCols.size(); j++)        {          String forColType = GetColumnType(tblName, forCols.elementAt(j));          String refColType = GetColumnType(refTblName, refCols.elementAt(j));          if (!forColType.equals(refColType))          {            if (forColType.contains("char") && refColType.contains("char"))            {              continue;            }            else            {              return true;            }          }        }      }    }    return false;  }}// Get table names of DB and check whether this table existsboolean CheckNoSuchTable(String tblName) :{}{  {    Vector < String > tblNames = myDB.getDB("@table name");    return !tblNames.contains(tblName);  }}// Get referenced table names of DB and check whether this table is referenced by other tableboolean CheckDropReferencedTable(String refTblName) :{}{  {    Vector < String > tblNames = myDB.getDB(refTblName + " @referenced by");    return !(tblNames.size() == 0);  }}// Check whether there is no tableboolean CheckShowTablesNoTable() :{}{  {    Vector < String > tblNames = myDB.getDB("@table name");    return (tblNames.size() == 0);  }}String CheckInsertColumnExistence(String tblName, Vector < String > cols) :{}{  {    Vector < String > colNames = GetAllColumns(tblName);    for (int i = 0; i < cols.size(); i++)    {      if (!colNames.contains(cols.elementAt(i)))      {        return cols.elementAt(i);      }    }    return null;  }}// User defined error
boolean CheckInsertDuplicateColumn(Vector < String > cols) :{}{  {    for (int i = 0; i < cols.size() - 1; i++)    {      for (int j = i + 1; j < cols.size(); j++)      {        if (cols.elementAt(i).equals(cols.elementAt(j)))        {          return true;        }      }    }    return false;  }}void CheckInsertColumnNonNullableAndTypeMismatch(String tblName, Vector < String > cols, Vector < String > values) :{}{  {    Vector < String > allColumns = GetAllColumns(tblName);    // if column list exists    if (cols.size() > 0)    { // if column list's size is not same as value list's size      if (cols.size() != values.size())      {        InsertTypeMismatchError();      }      // if column list's size is smaller than entire column list
      // we should set null to columns that are not in column list      if (cols.size() < allColumns.size())      {        for (int i = 0; i < allColumns.size(); i++)        {          String col = allColumns.elementAt(i);          if (!cols.contains(col) && !IsColumnNullable(tblName, col))          {            InsertColumnNonNullableError(col);          }        }      }      else      { // nullable error check
        for (int i = 0; i < cols.size(); i++)        {          String colAt = cols.elementAt(i);          String valAt = values.elementAt(i);          if (!IsColumnNullable(tblName, colAt) && valAt.equals("null"))          {            InsertColumnNonNullableError(colAt);          }        }      }      // type error check
      for (int i = 0; i < cols.size(); i++)      {        String colAt = cols.elementAt(i);        String valAt = values.elementAt(i);        String typAt = GetColumnType(tblName, colAt);        // if value is int type
        if (typAt.equals("int"))        {          if (!valAt.equals("null") && !CheckInteger(valAt))          {            InsertTypeMismatchError();          }        }        // if value is date type
        else if (typAt.equals("date"))        {          if (!valAt.equals("null") && !CheckDate(valAt))          {            InsertTypeMismatchError();          }        }        // if value is char(...) type
        else if (typAt.substring(0, 4).equals("char"))        {          if (!valAt.equals("null") && !CheckString(valAt))          {            InsertTypeMismatchError();          }        }      }    }    // if column list doesn't exist
    else    {      if (allColumns.size() != values.size())      {        InsertTypeMismatchError();      }      else      {        for (int i = 0; i < allColumns.size(); i++)        {          String colAt = allColumns.elementAt(i);          String valAt = values.elementAt(i);          String typAt = GetColumnType(tblName, colAt);          // nullable error check
          if (!IsColumnNullable(tblName, colAt) && valAt.equals("null"))          {            InsertColumnNonNullableError(colAt);          }          // if value is int type
          if (typAt.equals("int"))          {            if (!valAt.equals("null") && !CheckInteger(valAt))            {              InsertTypeMismatchError();            }          }          // if value is date type
          else if (typAt.equals("date"))          {            if (!valAt.equals("null") && !CheckDate(valAt))            {              InsertTypeMismatchError();            }          }          // if value is char(...) type
          else if (typAt.substring(0, 4).equals("char"))          {            if (!valAt.equals("null") && !CheckString(valAt))            {              InsertTypeMismatchError();            }          }        }      }    }  }}boolean CheckInsertDuplicatePrimaryKey(String tblName, Vector < String > cols, Vector < String > values) :{}{  {    if (myDB.getDB(tblName + " @primary key").size() == 0)    {      return false;    }    Vector < String > priKeyCols = GetPrimaryKeyColumns(tblName);    Vector < Vector < String >> priKeyVals = GetRecordsByColumns(tblName, priKeyCols);    Vector < String > priKeyVal = new Vector < String > ();    for (int i = 0; i < priKeyCols.size(); i++)    {      String priKeyColAt = priKeyCols.elementAt(i);      int priKeyColIdx;      if (cols.size() > 0)      {        priKeyColIdx = cols.indexOf(priKeyColAt);      }      else      {        priKeyColIdx = GetColumnIndex(tblName, priKeyColAt);      }      String val = values.elementAt(priKeyColIdx);      String typ = GetColumnType(tblName, priKeyColAt);      if (typ.contains("char"))      { // truncate string
        int typlen = Integer.parseInt(typ.substring(5, typ.length() - 1));        int varlen = val.length() - 2;        if (typlen < varlen)        {          val = val.substring(0, typlen + 1) + "'";        }      }      else if (typ.contains("int"))      {        val = String.valueOf(Integer.parseInt(val));      }      priKeyVal.addElement(val);    }    return priKeyVals.contains(priKeyVal);  }}// Check whether foreign key references non-existing value in referenced table
boolean CheckInsertReferentialIntegrity(String tblName, Vector < String > cols, Vector < String > values) :{}{  {    Vector < String > refTbls = GetReferenceTables(tblName);    // for each foreign key definition
    for (int i = 0; i < refTbls.size(); i++)    {      String refTblAt = refTbls.elementAt(i);      Vector < String > forKeyCols = GetForeignKeyColumns(tblName, refTblAt);      Vector < Vector < String >> refVals = GetRecordsByColumns(refTblAt, GetPrimaryKeyColumns(refTblAt));      // check if value of primary key of referenced table contains foreign key value of this table
      Vector < String > forKeyVals = new Vector < String > ();      for (int j = 0; j < forKeyCols.size(); j++)      {        String forKeyColAt = forKeyCols.elementAt(j);        int forKeyColIdx;        if (cols.size() > 0)        {          forKeyColIdx = cols.indexOf(forKeyColAt);        }        else        {          forKeyColIdx = GetColumnIndex(tblName, forKeyColAt);        }        String val = values.elementAt(forKeyColIdx);        String typ = GetColumnType(tblName, forKeyColAt);        if (val.equals("null"))        {          return false;        }        if (typ.contains("char"))        { // truncate string
          int typlen = Integer.parseInt(typ.substring(5, typ.length() - 1));          int varlen = val.length() - 2;          if (typlen < varlen)          {            val = val.substring(0, typlen + 1) + "'";          }        }        else if (typ.contains("int"))        {          val = String.valueOf(Integer.parseInt(val));        }        forKeyVals.addElement(val);      }      if (!refVals.contains(forKeyVals))      {        return true;      }    }    return false;  }}String CheckSelectTableExistence(Vector < String > tblNames) :{}{  {    Vector < String > allTblNames = myDB.getDB("@table name");    for (int i = 0; i < tblNames.size(); i++)    {      String tblNameAt = tblNames.elementAt(i);      if (!allTblNames.contains(tblNameAt))      {        return tblNameAt;      }    }    return null;  }}String CheckSelectColumnResolve(Vector < String > tblNames, Vector < String > colNames) :{}{  {    for (int i = 0; i < colNames.size(); i++)    {      String colNameAt = colNames.elementAt(i);      // tbl.col form
      if (colNameAt.contains("."))      {        StringTokenizer st = new StringTokenizer(colNameAt, ".");        String tblName = st.nextToken();        String colName = st.nextToken();        if (!tblNames.contains(tblName))        {          return colName;        }        Vector < String > allCols = GetAllColumns(tblName);        if (!allCols.contains(colName))        {          return colName;        }      }      // col form
      else      {        int cnt = 0;        for (int j = 0; j < tblNames.size(); j++)        {          String tblNameAt = tblNames.elementAt(j);          Vector < String > allCols = GetAllColumns(tblNameAt);          if (allCols.contains(colNameAt))          {            cnt++;          }        }        if (cnt != 1)        {          return colNameAt;        }      }    }    return null;  }}// Utility Functions
Vector < String > GetReferenceTables(String tblName) :{}{  {    Vector < String > forKeyDefs = myDB.getDB(tblName + " @foreign key");    Vector < String > refTbls = new Vector < String > ();    for (int i = 0; i < forKeyDefs.size(); i++)    {      String forKeyDefAt = forKeyDefs.elementAt(i);      StringTokenizer st = new StringTokenizer(forKeyDefAt, delim);      while (st.hasMoreTokens())      {        String refTblName = st.nextToken();        if (refTblName.contains("references"))        {          refTblName = refTblName.substring(12);          refTbls.addElement(refTblName);          break;        }      }    }    return refTbls;  }}// Get record's value by column name
Vector < Vector < String >> GetRecordsByColumns(String tblName, Vector < String > colNames) :{}{  {    Vector < Vector < String >> allRecords = GetAllRecords(tblName);    Vector < Vector < String >> records = new Vector < Vector < String >> ();    Vector < Integer > colIndices = new Vector < Integer > ();    for (int i = 0; i < colNames.size(); i++)    {      colIndices.addElement(GetColumnIndex(tblName, colNames.elementAt(i)));    }    for (int i = 0; i < allRecords.size(); i++)    {      Vector < String > recordAt = allRecords.elementAt(i);      Vector < String > newRecord = new Vector < String > ();      for (int j = 0; j < colNames.size(); j++)      {        newRecord.addElement(recordAt.elementAt(colIndices.elementAt(j)));      }      records.addElement(newRecord);    }    return records;  }}int GetColumnIndex(String tblName, String colName) :{}{  {    Vector < String > colNames = GetAllColumns(tblName);    return colNames.indexOf(colName);  }}Vector < String > GetPrimaryKeyColumns(String tblName) :{}{  {    Vector < String > priKeyCols = new Vector < String > ();    if (myDB.getDB(tblName + " @primary key").size() > 0)    {      String priKeyColStr = myDB.getDB(tblName + " @primary key").elementAt(0);      StringTokenizer st = new StringTokenizer(priKeyColStr, delim);      while (st.hasMoreTokens())      {        String col = st.nextToken();        priKeyCols.addElement(col);      }    }    return priKeyCols;  }}Vector < String > GetForeignKeyColumns(String tblName, String refTblName) :{}{  {    Vector < String > forKeyCols = new Vector < String > ();    Vector < String > forKeyDefs = myDB.getDB(tblName + " @foreign key");    for (int i = 0; i < forKeyDefs.size(); i++)    {      forKeyCols = new Vector < String > ();      String forKeyDefAt = forKeyDefs.elementAt(i);      StringTokenizer st = new StringTokenizer(forKeyDefAt, delim);      while (st.hasMoreTokens())      {        String col = st.nextToken();        if (col.contains("references"))        {          String refTbl = col.substring(12);          if (refTbl.equals(refTblName))          {            return forKeyCols;          }          else          {            break;          }        }        else        {          forKeyCols.addElement(col);        }      }    }    return forKeyCols;  }}Vector < String > GetAllColumns(String tblName) :{}{  {    Vector < String > colNames = new Vector < String > ();    String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);    StringTokenizer st = new StringTokenizer(colDefStr, delim);    while (st.hasMoreTokens())    {      String colName = st.nextToken();      String colType = st.nextToken();      colNames.addElement(colName);    }    return colNames;  }}Vector < Vector < String >> GetAllRecords(String tblName) :{}{  {    Vector < String > recordsStr = myDB.getDB(tblName + " @record");    Vector < Vector < String >> recordsVect = new Vector < Vector < String >> ();    for (int i = 0; i < recordsStr.size(); i++)    {      String recordStrAt = recordsStr.elementAt(i);      Vector < String > record = new Vector < String > ();      StringTokenizer st = new StringTokenizer(recordStrAt, delim);      while (st.hasMoreTokens())      {        String val = st.nextToken();        record.addElement(val);      }      recordsVect.addElement(record);    }    return recordsVect;  }}Vector < Vector < String >> GetJoinedRecords(Vector < String > tblNames) :{}{  { // a.x a.y b.z b.w
    Vector < Vector < String >> result = new Vector < Vector < String >> ();    Vector < Vector < String >> tmpResult;    Vector < String > allCols = new Vector < String > ();    for (int i = 0; i < tblNames.size(); i++)    {      String tblNameAt = tblNames.elementAt(i);      Vector < String > cols = GetAllColumns(tblNameAt);      for (int j = 0; j < cols.size(); j++)      {        allCols.addElement(tblNameAt + "." + cols.elementAt(j));      }    }    result.addElement(allCols);    Vector < String > tmp = new Vector < String > (tblNames);    tmpResult = CartesianProduct(tmp);    for (int i = 0; i < tmpResult.size(); i++)    {      result.addElement(tmpResult.elementAt(i));    }    return result;  }}// Get type of column
String GetColumnType(String tblName, String colName) :{}{  {    String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);    StringTokenizer st = new StringTokenizer(colDefStr, delim);    while (st.hasMoreTokens())    {      String _colName = st.nextToken();      String colType = st.nextToken();      if (colName.equals(_colName))      {        StringTokenizer st2 = new StringTokenizer(colType, "*");        return st2.nextToken();      }    }    return null;  }}// recursive cartesian product
Vector < Vector < String >> CartesianProduct(Vector < String > tblNames) :{}{  {    String tblNameAt = tblNames.elementAt(0);    Vector < Vector < String >> left = GetAllRecords(tblNameAt);    Vector < Vector < String >> result = new Vector < Vector < String >> ();    if (tblNames.size() < 2)    {      return left;    }    else    {      tblNames.remove(0);      Vector < Vector < String >> right = CartesianProduct(tblNames);      for (int i = 0; i < left.size(); i++)      {        Vector < String > leftRecordAt = left.elementAt(i);        for (int j = 0; j < right.size(); j++)        {          Vector < String > rightRecordAt = right.elementAt(j);          Vector < String > tmp = new Vector < String > (leftRecordAt);          for (int k = 0; k < rightRecordAt.size(); k++)          {            String val = rightRecordAt.elementAt(k);            tmp.addElement(val);          }          result.addElement(tmp);        }      }      return result;    }  }}// Change columns of primary key to not null
void ChangeToNotNull(String tblName) :{}{  {    Vector < String > priKeys = myDB.getDB(tblName + " @primary key");    if (priKeys.size() > 0)    {      // Get primary keys      Vector < String > priKeyCols = GetPrimaryKeyColumns(tblName);      String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);      myDB.deleteDB(tblName + " @column definition");      StringTokenizer st2 = new StringTokenizer(colDefStr, delim);      String newColDef = "";      // Change type of primary keys to not null by deleting and re-inserting primary key data
      while (st2.hasMoreTokens())      {        String colName = st2.nextToken();        String colType = st2.nextToken();        StringTokenizer st3 = new StringTokenizer(colType, "*");        String realColType = st3.nextToken();        if (priKeyCols.contains(colName) && !st3.hasMoreTokens())        {          newColDef += "|" + colName + "|" + realColType + "*not null";        }        else        {          newColDef += "|" + colName + "|" + colType;        }      }      myDB.putDB(tblName + " @column definition", newColDef.substring(1));    }  }}// Perform drop table queryvoid DropTable(String tblName) :{}{  {    myDB.deleteTable(tblName);    myDB.deleteDB("@table name");    tblNameList.remove(tblName);    for (int i = 0; i < tblNameList.size(); i++)    {      myDB.putDB("@table name", tblNameList.elementAt(i));    }  }}// Perform show tables queryvoid ShowTables() :{}{  {    Vector < String > tblNames = myDB.getDB("@table name");    System.out.println("-------------------------");    for (int i = 0; i < tblNames.size(); i++)    {      System.out.println(tblNames.elementAt(i));    }    System.out.println("-------------------------");  }}// Check whether given column is primary key column
boolean IsPrimaryKey(String tblName, String colName) :{}{  {    Vector < String > priKeyCols = GetPrimaryKeyColumns(tblName);    return priKeyCols.contains(colName);  }}// Check whether given column is foreign key columnboolean IsForeignKey(String tblName, String colName) :{}{  {    Vector < String > forKeys = myDB.getDB(tblName + " @foreign key");    for (int i = 0; i < forKeys.size(); i++)    {      String forKeyDef = forKeys.elementAt(i);      StringTokenizer st = new StringTokenizer(forKeyDef, delim);      while (st.hasMoreTokens())      {        String tmp = st.nextToken();        if (tmp.contains("references"))        {          break;        }        else if (tmp.equals(colName))        {          return true;        }      }    }    return false;  }}// Perform desc query
void Desc(String tblName) :{}{  {    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);    StringTokenizer st = new StringTokenizer(colDef, delim);    System.out.println("------------------------------------------------------------");    System.out.println("table_name [" + tblName + "]");    System.out.printf("%-25s%-15s%-10s%-10s\n", "column_name", "type", "null", "key");    while (st.hasMoreTokens())    {      String colName = st.nextToken();      String colType = st.nextToken();      boolean isNotNull = false;      boolean isPriKey = IsPrimaryKey(tblName, colName);      boolean isForKey = IsForeignKey(tblName, colName);      StringTokenizer st2 = new StringTokenizer(colType, "*");      String realColType = st2.nextToken();      if (st2.hasMoreTokens())      {        isNotNull = true;      }      System.out.printf("%-25s%-15s", colName, realColType);      if (isNotNull)      {        System.out.printf("%-10s", "N");      }      else      {        System.out.printf("%-10s", "Y");      }      if (isPriKey && isForKey)      {        System.out.printf("%-10s\n", "PRI/FOR");      }      else if (isPriKey)      {        System.out.printf("%-10s\n", "PRI");      }      else if (isForKey)      {        System.out.printf("%-10s\n", "FOR");      }      else      {        System.out.print("\n");      }    }    System.out.println("------------------------------------------------------------");  }}boolean CheckInteger(String num) :{}{  {    try    {      Integer.parseInt(num);    }    catch (NumberFormatException e)    {      return false;    }    return true;  }}boolean CheckDate(String date) :{  boolean isLeapYear = false;  String year;  String month;  String day;  int yearInt = 0, monthInt = 0, dayInt = 0;}{  {    StringTokenizer st = new StringTokenizer(date, "-");    year = new String();    month = new String();    day = new String();    year = st.nextToken();    if (CheckInteger(year) && year.length() == 4 && st.hasMoreTokens())    {      month = st.nextToken();      yearInt = Integer.parseInt(year);      // leap year check
      if (yearInt % 4 == 0)      {        if (yearInt % 100 == 0)        {          if (yearInt % 400 == 0)          {            isLeapYear = true;          }          else          {            isLeapYear = false;          }        }        else        {          isLeapYear = true;        }      }      else      {        isLeapYear = false;      }      if (CheckInteger(month) && month.length() == 2 && st.hasMoreTokens())      {        day = st.nextToken();        monthInt = Integer.parseInt(month);        if (CheckInteger(day) && day.length() == 2)        {          dayInt = Integer.parseInt(day);        }        else        {          return false;        }      }      else      {        return false;      }    }    else    {      return false;    }    // date range checking    switch (monthInt)    {      case 2 : if (isLeapYear)      {        if (dayInt < 1 || dayInt > 29)        {          InvalidDateRangeError();          return false;        }      }      else      {        if (dayInt < 1 || dayInt > 28)        {          InvalidDateRangeError();          return false;        }      }      break;      case 1 : case 3 : case 5 : case 7 : case 8 : case 10 : case 12 : if (dayInt < 1 || dayInt > 31)      {        InvalidDateRangeError();        return false;      }      break;      case 4 : case 6 : case 9 : case 11 : if (dayInt < 1 || dayInt > 30)      {        InvalidDateRangeError();        return false;      }      break;      default : InvalidDateRangeError();      return false;    }    return true;  }}boolean CheckString(String str) :{}{  {    return str.startsWith("'") && str.endsWith("'");  }}void InsertValues(String tblName, Vector < String > cols, Vector < String > values) :{}{  {    Vector < String > colNames = GetAllColumns(tblName);    String valArr [ ] = new String [ colNames.size() ];    for (int i = 0; i < valArr.length; i++)    {      valArr [ i ] = "null";    }    // if column list exists
    if (cols.size() > 0)    {      for (int i = 0; i < cols.size(); i++)      {        String col = cols.elementAt(i);        String val = values.elementAt(i);        String typ = GetColumnType(tblName, col);        if (val.equals("null"))        {          continue;        }        else if (typ.contains("char"))        { // truncate string          int typlen = Integer.parseInt(typ.substring(5, typ.length() - 1));          int varlen = val.length() - 2;          if (typlen < varlen)          {            val = val.substring(0, typlen + 1) + "'";          }        }        else if (typ.contains("int"))        {          val = String.valueOf(Integer.parseInt(val));        }        int match = colNames.indexOf(col);        valArr [ match ] = val;      }    }    // if column list does not exists
    else    {      for (int i = 0; i < values.size(); i++)      {        String col = GetAllColumns(tblName).elementAt(i);        String val = values.elementAt(i);        String typ = GetColumnType(tblName, col);        if (val.equals("null"))        {          continue;        }        else if (typ.contains("char"))        { // truncate string
          int typlen = Integer.parseInt(typ.substring(5, typ.length() - 1));          int varlen = val.length() - 2;          if (typlen < varlen)          {            val = val.substring(0, typlen + 1) + "'";          }        }        else if (typ.contains("int"))        {          val = String.valueOf(Integer.parseInt(val));        }        valArr [ i ] = val;      }    }    String valStr = "";    for (int i = 0; i < valArr.length; i++)    {      valStr += delim + valArr [ i ];    }    valStr = valStr.substring(1);    myDB.putDB(tblName + " @record", valStr);  }}boolean IsColumnNullable(String tblName, String colName) :{}{  {    String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);    StringTokenizer st = new StringTokenizer(colDefStr, delim);    while (st.hasMoreTokens())    {      String col = st.nextToken();      String colType = st.nextToken();      if (col.equals(colName))      {        StringTokenizer st2 = new StringTokenizer(colType, "*");        st2.nextToken();        return !st2.hasMoreTokens();      }    }  }}void UpdateTable(String tblName, Vector < Vector < String >> allRecords) :{}{  {    myDB.deleteDB(tblName + " @record");    for (int i = 0; i < allRecords.size(); i++)    {      Vector < String > recordAt = allRecords.elementAt(i);      String recordStrAt = new String();      for (int j = 0; j < recordAt.size(); j++)      {        String val = recordAt.elementAt(j);        recordStrAt += delim + val;      }      recordStrAt = recordStrAt.substring(1);      myDB.putDB(tblName + " @record", recordStrAt);    }  }}void DeleteRecords(String tblName, Vector < LogicValue > evalResult, Vector < Boolean > performDelete) :{}{  {    Vector < String > recordsStr = myDB.getDB(tblName + " @record");    Vector < String > result = new Vector < String > ();    int delCnt = 0, notDelCnt = 0;    myDB.deleteDB(tblName + " @record");    // if there is 0 record in table
    if (evalResult.size() == 0 && performDelete == null)    {      DeleteResult(0);      DeleteReferentialIntegrityPassed(0);      return;    }    // if there is 0 record in table
    if (evalResult.size() == 0 && performDelete.size() == 0)    {      DeleteResult(0);      DeleteReferentialIntegrityPassed(0);      return;    }    for (int i = 0; i < recordsStr.size(); i++)    {      String recordStrAt = recordsStr.elementAt(i);      LogicValue eval = evalResult.elementAt(i);      if (performDelete != null)      {        boolean delete = performDelete.elementAt(i);        if (eval == LogicValue.T && delete)        {          delCnt++;        }        else if (eval == LogicValue.T && !delete)        {          notDelCnt++;        }        if (eval != LogicValue.T || !delete)        {          result.addElement(recordStrAt);        }      }      else      {        if (eval == LogicValue.T)        {          delCnt++;        }        else        {          result.addElement(recordStrAt);        }      }    }    for (int i = 0; i < result.size(); i++)    {      myDB.putDB(tblName + " @record", result.elementAt(i));    }    DeleteResult(delCnt);    DeleteReferentialIntegrityPassed(notDelCnt);  }}void DeleteRecordsCascade(String tblName, Vector < LogicValue > evalResult, Vector < Boolean > performDelete) :{}{  {    Vector < String > recordsStr = myDB.getDB(tblName + " @record");    Vector < String > refTblNames = myDB.getDB(tblName + " @referenced by");    Vector < String > result = new Vector < String > ();    Vector < String > priKeyCols = GetPrimaryKeyColumns(tblName);    Vector < Vector < String >> priKeyVals = GetRecordsByColumns(tblName, priKeyCols);    // if there is 0 record in table, do nothing
    if (evalResult.size() == 0 && performDelete.size() == 0)    {      return;    }    // for each primary key value, update corresponding foreign key values to null if they are nullable
    for (int i = 0; i < priKeyVals.size(); i++)    {      Vector < String > priKeyValAt = priKeyVals.elementAt(i);      boolean delete = performDelete.elementAt(i);      LogicValue eval = evalResult.elementAt(i);      if (eval == LogicValue.T && delete)      {        for (int j = 0; j < refTblNames.size(); j++)        {          String refTblNameAt = refTblNames.elementAt(j);          Vector < String > forKeyCols = GetForeignKeyColumns(refTblNameAt, tblName);          Vector < Vector < String >> forKeyVals = GetRecordsByColumns(refTblNameAt, forKeyCols);          Vector < Vector < String >> allRecordsRefTbl = GetAllRecords(refTblNameAt);          for (int k = 0; k < forKeyVals.size(); k++)          {            Vector < String > forKeyValAt = forKeyVals.elementAt(k);            Vector < String > recordAt = allRecordsRefTbl.elementAt(k);            if (priKeyValAt.equals(forKeyValAt))            {              // update to null
              for (int l = 0; l < forKeyCols.size(); l++)              {                String forKeyColAt = forKeyCols.elementAt(l);                int idx = GetColumnIndex(refTblNameAt, forKeyColAt);                recordAt.setElementAt("null", idx);              }              allRecordsRefTbl.setElementAt(recordAt, k);            }          }          // update table to updated records          UpdateTable(refTblNameAt, allRecordsRefTbl);        }      }    }    // delete records of this table
    DeleteRecords(tblName, evalResult, performDelete);  }}void CascadeDelete(String tblName, Vector < LogicValue > evalResult) :{}{  {    Vector < Boolean > performDelete = new Vector < Boolean > ();    Vector < String > refTblNames = myDB.getDB(tblName + " @referenced by");    // no table is referencing this table, so just delete records
    if (refTblNames.size() == 0)    {      DeleteRecords(tblName, evalResult, null);    }    // if there are some tables referencing this table
    else    {      Vector < String > priKeyCols = GetPrimaryKeyColumns(tblName);      Vector < Vector < String >> priKeyVals = GetRecordsByColumns(tblName, priKeyCols);      for (int i = 0; i < priKeyVals.size(); i++)      {        LogicValue eval = evalResult.elementAt(i);        Vector < String > priKeyValAt = priKeyVals.elementAt(i);        if (eval != LogicValue.T)        {          performDelete.addElement(false);          continue;        }        else        {          boolean delete = true;          for (int j = 0; j < refTblNames.size(); j++)          {            String refTblNameAt = refTblNames.elementAt(j);            Vector < String > forKeyCols = GetForeignKeyColumns(refTblNameAt, tblName);            Vector < Vector < String >> forKeyVals = GetRecordsByColumns(refTblNameAt, forKeyCols);            boolean isColumnNonNullable = false;            // if there is a record referencing this primary key value, delete is not performed for this record
            if (forKeyVals.contains(priKeyValAt))            {              for (int k = 0; k < forKeyCols.size(); k++)              {                String forKeyColAt = forKeyCols.elementAt(k);                if (!IsColumnNullable(refTblNameAt, forKeyColAt))                {                  isColumnNonNullable = true;                  delete = false;                  break;                }              }              if (isColumnNonNullable)              {                break;              }            }          }          performDelete.addElement(delete);        }      }      DeleteRecordsCascade(tblName, evalResult, performDelete);    }  }}void SelectPrint(Vector < Vector < String >> records, Vector < String > colNames) :{}{  {    if (colNames == null)    {      colNames = records.elementAt(0);    }    String pretty = new String();    for (int i = 0; i < colNames.size(); i++)    {      pretty += "+------------------------";    }    pretty += "+";    System.out.println(pretty);    String colStr = new String();    for (int i = 0; i < colNames.size(); i++)    {      String colAt = colNames.elementAt(i);      if (colAt.contains("."))      {        StringTokenizer st = new StringTokenizer(colAt, ".");        st.nextToken();        colAt = st.nextToken();      }      System.out.printf("%-25s", "| " + colAt.toUpperCase());    }    System.out.printf("|\n");    System.out.println(pretty);    for (int i = 1; i < records.size(); i++)    {      Vector < String > recordAt = records.elementAt(i);      for (int j = 0; j < recordAt.size(); j++)      {        String val = recordAt.elementAt(j);        if (CheckString(val))        {          val = val.substring(1, val.length() - 1);        }        System.out.printf("%-25s", "| " + val);      }      System.out.printf("|\n");    }    System.out.println(pretty);  }}// Check if given string is keyword
boolean IsKeyword(String s) :{}{  {    return keywordSet.contains(s.toLowerCase());  }}// Parsing Functions
void Command() :{}{  QueryList()}void QueryList() :{}{  (    Query()  )+}void Query() :{}{  (    CreateTableQuery()  | DropTableQuery()  | ShowTablesQuery()  | DescQuery()  | SelectQuery()  | InsertQuery()  | DeleteQuery()  | ExitQuery()  )}void ExitQuery() :{}{  < EXIT >  (    < SEMICOLON >  |    (      (        ";\r"      | ";\n"      )    )  )  {    myDB.closeDB();    System.exit(0);  }}void CreateTableQuery() :{  String tblName;  String colName;  boolean isNewLine = false;}{  < CREATE_TABLE > tblName = TableName()  {    if (CheckTableExistence(tblName))    {      TableExistenceError();    }  }  TableElementList(tblName)  (    < SEMICOLON >  |    (      (        ";\r"      | ";\n"      )      {        isNewLine = true;      }    )  )  {    myDB.putDB(tblName + " @column definition", tmpColDef.substring(1));    tmpColDef = "";    tmpPriKey = "";    tmpForKey = "";    if (CheckDuplicateColumnDef(tblName))    {      DuplicateColumnDefError(tblName);    }    else if (CheckDuplicatePrimaryKeyDef(tblName))    {      DuplicatePrimaryKeyDefError(tblName);    }    else if ((colName = CheckNonExistingColumnDef(tblName)) != null)    {      NonExistingColumnDefError(tblName, colName);    }    else if (CheckReferenceTableExistence(tblName))    {      ReferenceTableExistenceError(tblName);    }    else if (CheckReferenceColumnExistence(tblName))    {      ReferenceColumnExistenceError(tblName);    }    else if (CheckReferenceNonPrimaryKey(tblName))    {      ReferenceNonPrimaryKeyError(tblName);    }    else if (CheckReferenceType(tblName))    {      ReferenceTypeError(tblName);    }    ChangeToNotNull(tblName);    createTblName = tblName;    myDB.putDB("@table name", tblName);    tblNameList.addElement(tblName);    CreateTableSuccess();    if (isNewLine)    {      System.out.print("SQL_2011-11693 > ");    }  }}void TableElementList(String tblName) :{}{  < LEFT_PAREN > TableElement(tblName)  (    < COMMA > TableElement(tblName)  )*  < RIGHT_PAREN >}void TableElement(String tblName) :{}{  ColumnDefinition()| TableConstraintDefinition(tblName)}void ColumnDefinition() :{  String colName = "";  String dataType = "";  String notNull = "";}{  (    LOOKAHEAD(ColumnName() DataType() < NOT_NULL >)    (      colName = ColumnName() dataType = DataType() < NOT_NULL >      {        notNull = "*not null";      }    )  |    (      colName = ColumnName() dataType = DataType()    )  )  (  {    tmpColDef += delim + colName + delim + dataType + notNull;  }  )}void TableConstraintDefinition(String tblName) :{}{  PrimaryKeyConstraint(tblName)| ReferentialKeyConstraint(tblName)}void PrimaryKeyConstraint(String tblName) :{}{  < PRIMARY_KEY > ColumnNameList(true)  {    myDB.putDB(tblName + " @primary key", tmpPriKey.substring(1));  }}void ReferentialKeyConstraint(String tblName) :{  String referedTblName;}{  < FOREIGN_KEY > ColumnNameList(false) < REFERENCES > referedTblName = TableName()  {    myDB.putDB(referedTblName + " @referenced by", tblName);    tmpForKey += delim + "@references&" + referedTblName;  }  ColumnNameList(false)  {    myDB.putDB(tblName + " @foreign key", tmpForKey.substring(1));    tmpForKey = "";  }}void ColumnNameList(boolean isPrimaryKey) :{  String colName;}{  < LEFT_PAREN > colName = ColumnName()  {    if (isPrimaryKey)    {      tmpPriKey += delim + colName;    }    else    {      tmpForKey += delim + colName;    }  }  (    < COMMA > colName = ColumnName()    {      if (isPrimaryKey)      {        tmpPriKey += delim + colName;      }      else      {        tmpForKey += delim + colName;      }    }  )*  < RIGHT_PAREN >}String DataType() :{  Token size;}{  < INT >  {    return "int";  }|  (    < CHAR > < LEFT_PAREN >    (      size = < INT_VALUE >    | size = < DIGIT >    )    < RIGHT_PAREN >    {      if (Integer.parseInt(size.image) <= 0) CharLengthError();      return "char(" + Integer.toString(Integer.parseInt(size.image)) + ")";    }  )| < DATE >  {    return "date";  }}String TableName() :{  Token t;}{  (    t = < LEGAL_IDENTIFIER >    {      if (IsKeyword(t.image))      {        throw new ParseException();      }    }  | t = < ALPHABET >  )  {    return t.image.toLowerCase();  }}String ColumnName() :{  Token t;}{  (    t = < LEGAL_IDENTIFIER >    {      if (IsKeyword(t.image))      {        throw new ParseException();      }    }  | t = < ALPHABET >  )  {    return t.image.toLowerCase();  }}void DropTableQuery() :{  String tblName;  boolean isNewLine = false;}{  < DROP_TABLE > tblName = TableName()  (    < SEMICOLON >  |    (      (        ";\r"      | ";\n"      )      {        isNewLine = true;      }    )  )  {    if (CheckNoSuchTable(tblName))    {      NoSuchTable();    }    else if (CheckDropReferencedTable(tblName))    {      DropReferencedTableError(tblName);    }    else    {      dropTblName = tblName;      DropTable(tblName);    }    DropSuccess();    if (isNewLine)    {      System.out.print("SQL_2011-11693 > ");    }  }}void ShowTablesQuery() :{  boolean isNewLine = false;}{  < SHOW_TABLES >  (    < SEMICOLON >  |    (      (        ";\r"      | ";\n"      )      {        isNewLine = true;      }    )  )  {    if (CheckShowTablesNoTable())    {      ShowTablesNoTable();    }    else    {      ShowTables();    }    if (isNewLine)    {      System.out.print("SQL_2011-11693 > ");    }  }}void DescQuery() :{  String tblName;  boolean isNewLine = false;}{  < DESC > tblName = TableName()  (    < SEMICOLON >  |    (      (        ";\r"      | ";\n"      )      {        isNewLine = true;      }    )  )  {    if (CheckNoSuchTable(tblName))    {      NoSuchTable();    }    else    {      Desc(tblName);    }    if (isNewLine)    {      System.out.print("SQL_2011-11693 > ");    }  }}void SelectQuery() :{  boolean isNewLine = false;  Vector < String > selCols;}{  < SELECT > selCols = SelectList() TableExpression(selCols)  (    < SEMICOLON >  |    (      (        ";\r"      | ";\n"      )      {        isNewLine = true;      }    )  )  {    if (isNewLine)    {      System.out.print("SQL_2011-11693 > ");    }  }}Vector < String > SelectList() :{  String colName;  Vector < String > colNames = new Vector < String > ();}{  ("*"  {    return colNames;  }  )|  (    colName = SelectedColumn()    {      colNames.addElement(colName);    }    (      < COMMA > colName = SelectedColumn()      {        colNames.addElement(colName);      }    )*    {      return colNames;    }  )}String SelectedColumn() :{  String tblName = new String();  String colName = new String();}{  LOOKAHEAD(TableName() < PERIOD > ColumnName())  (    tblName = TableName() < PERIOD > colName = ColumnName()    {      return tblName + "." + colName;    }  )|  (    colName = ColumnName()    {      return colName;    }  )}void TableExpression(Vector < String > selectColumns) :{  Vector < String > fromTables;  Vector < LogicValue > evalResult;  String nonexistCol;}{  (    LOOKAHEAD(FromClause() WhereClause())    (      fromTables = FromClause()       evalResult = WhereClause(fromTables)    )  |    (      fromTables = FromClause()      {        evalResult = new Vector < LogicValue > ();        int joinedRecSize = GetJoinedRecords(fromTables).size() - 1;        for (int i = 0; i < joinedRecSize; i++)        {          evalResult.addElement(LogicValue.T);        }      }    )  )  {    if ((nonexistCol = CheckSelectColumnResolve(fromTables, selectColumns)) != null)    {      SelectColumnResolveError(nonexistCol);    }    Vector < Vector < String >> joinedRecords = GetJoinedRecords(fromTables);    Vector < String > joinedColNames = joinedRecords.elementAt(0);    Vector < Vector < String >> midResult = new Vector < Vector < String >> ();    midResult.addElement(joinedColNames);    for (int i = 1; i < joinedRecords.size(); i++)    {      Vector < String > recordAt = joinedRecords.elementAt(i);      LogicValue eval = evalResult.elementAt(i - 1);      if (eval == LogicValue.T)      {        midResult.addElement(recordAt);      }    }    Vector < Vector < String >> finalResult = new Vector < Vector < String >> ();    // * (select all)
    if (selectColumns.size() == 0)    {      finalResult = midResult;      SelectPrint(finalResult, null);    }    else    {      Vector < String > tmp = new Vector < String > (selectColumns);      // initialize
      for (int i = 0; i < midResult.size(); i++)      {        Vector < String > newVect = new Vector < String > ();        finalResult.addElement(newVect);      }      for (int i = 0; i < selectColumns.size(); i++)      {        String selectColAt = selectColumns.elementAt(i);        // if col form, change to tbl.col form
        if (!selectColAt.contains("."))        {          String tblName = new String();          for (int j = 0; j < fromTables.size(); j++)          {            String fromTblAt = fromTables.elementAt(j);            Vector < String > colsAt = GetAllColumns(fromTblAt);            if (colsAt.contains(selectColAt))            {              tblName = fromTblAt;            }          }          selectColAt = tblName + "." + selectColAt;        }        int selectColIdx = joinedColNames.indexOf(selectColAt);        Vector < String > cols = finalResult.elementAt(0);        cols.addElement(joinedColNames.elementAt(selectColIdx));        for (int j = 1; j < finalResult.size(); j++)        {          Vector < String > recordAt = finalResult.elementAt(j);          String val = midResult.elementAt(j).elementAt(selectColIdx);          recordAt.addElement(val);          finalResult.setElementAt(recordAt, j);        }      }      SelectPrint(finalResult, tmp);    }  }}Vector < String > FromClause() :{  Vector < String > tblNames;  String nonexistTbl;}{  < FROM > tblNames = TableReferenceList()  {    if ((nonexistTbl = CheckSelectTableExistence(tblNames)) != null)    {      SelectTableExistenceError(nonexistTbl);    }    return tblNames;  }}Vector < String > TableReferenceList() :{  Vector < String > tblNames = new Vector < String > ();  String tblName;}{  tblName = ReferedTable()  {    tblNames.addElement(tblName);  }  (    < COMMA > tblName = ReferedTable()    {      tblNames.addElement(tblName);    }  )*  {    return tblNames;  }}String ReferedTable() :{  String tblName;}{  tblName = TableName()  {    return tblName;  }}Vector < LogicValue > WhereClause(Vector < String > tblNames) :{  Vector < LogicValue > result;}{  < WHERE >   result = BooleanValueExpression(tblNames)  {    return result;  }}Vector < LogicValue > BooleanValueExpression(Vector < String > tblNames) :{  Vector < LogicValue > l, r;}{  l = BooleanTerm(tblNames)  (    < OR >     r = BooleanTerm(tblNames)    { // three-valued logic
      for (int i = 0; i < l.size(); i++)      {        LogicValue lAt = l.elementAt(i);        LogicValue rAt = r.elementAt(i);        if (lAt == LogicValue.T || rAt == LogicValue.T)        {          l.setElementAt(LogicValue.T, i);        }        else if (lAt == LogicValue.U || rAt == LogicValue.U)        {          l.setElementAt(LogicValue.U, i);        }        else        {          l.setElementAt(LogicValue.F, i);        }      }    }  )*  {    return l;  }}Vector < LogicValue > BooleanTerm(Vector < String > tblNames) :{  Vector < LogicValue > l, r;}{  l = BooleanFactor(tblNames)  (    < AND >     r = BooleanFactor(tblNames)    { // three-valued logic
      for (int i = 0; i < l.size(); i++)      {        LogicValue lAt = l.elementAt(i);        LogicValue rAt = r.elementAt(i);        if (lAt == LogicValue.F || rAt == LogicValue.F)        {          l.setElementAt(LogicValue.F, i);        }        else if (lAt == LogicValue.U || rAt == LogicValue.U)        {          l.setElementAt(LogicValue.U, i);        }        else        {          l.setElementAt(LogicValue.T, i);        }      }    }  )*  {    return l;  }}Vector < LogicValue > BooleanFactor(Vector < String > tblNames) :{  Vector < LogicValue > l;}{  (    l = BooleanTest(tblNames)  |    (      < NOT >       l = BooleanTest(tblNames)      { // three-valued logic
        for (int i = 0; i < l.size(); i++)        {          LogicValue lAt = l.elementAt(i);          if (lAt == LogicValue.T)          {            l.setElementAt(LogicValue.F, i);          }          else if (lAt == LogicValue.F)          {            l.setElementAt(LogicValue.T, i);          }        }      }    )  )  {    return l;  }}Vector < LogicValue > BooleanTest(Vector < String > tblNames) :{  Vector < LogicValue > l;}{  (    l = Predicate(tblNames)  | l = ParentehsizedBooleanExpression(tblNames)  )  {    return l;  }}Vector < LogicValue > ParentehsizedBooleanExpression(Vector < String > tblNames) :{  Vector < LogicValue > l;}{  < LEFT_PAREN >   l = BooleanValueExpression(tblNames)   < RIGHT_PAREN >  {    return l;  }}Vector < LogicValue > Predicate(Vector < String > tblNames) :{  Vector < LogicValue > l;}{  (    LOOKAHEAD(ComparisonPredicate())    l = ComparisonPredicate(tblNames)  | l = NullPredicate(tblNames)  )  {    return l;  }}Vector < LogicValue > ComparisonPredicate(Vector < String > tblNames) :{  Vector < LogicValue > result = new Vector < LogicValue > ();  String l, r, op;}{  l = CompOperand(tblNames)   op = < COMP_OP >.image   r = CompOperand(tblNames)  {    Vector < Vector < String >> allRecords = GetJoinedRecords(tblNames);    Vector < String > colNames = allRecords.elementAt(0);    for (int i = 1; i < allRecords.size(); i++)    {      Vector < String > recordAt = allRecords.elementAt(i);      LogicValue logicVal;      String left, right;      boolean bool = false, isUnknown = false;      // if operand is column name
      if (!CheckInteger(l) && !CheckString(l) && !CheckDate(l))      {        // tbl.col form        if (l.contains("."))        {          int idx = colNames.indexOf(l);          left = recordAt.elementAt(idx);        }        // col form
        else        {          int idx = - 1;          for (int j = 0; j < colNames.size(); j++)          {            String tblColAt = colNames.elementAt(j);            StringTokenizer st = new StringTokenizer(tblColAt, ".");            st.nextToken();            String colAt = st.nextToken();            if (colAt.equals(l))            {              idx = j;              break;            }          }          left = recordAt.elementAt(idx);        }      }      else      {        left = l;      }      // if operand is column name
      if (!CheckInteger(r) && !CheckString(r) && !CheckDate(r))      {        // tbl.col form
        if (r.contains("."))        {          int idx = colNames.indexOf(r);          right = recordAt.elementAt(idx);        }        // col form
        else        {          int idx = - 1;          for (int j = 0; j < colNames.size(); j++)          {            String tblColAt = colNames.elementAt(j);            StringTokenizer st = new StringTokenizer(tblColAt, ".");            st.nextToken();            String colAt = st.nextToken();            if (colAt.equals(r))            {              idx = j;              break;            }          }          right = recordAt.elementAt(idx);        }      }      else      {        right = r;      }      // if two are integers
      if (CheckInteger(left) && CheckInteger(right))      {        int lhs = Integer.parseInt(left);        int rhs = Integer.parseInt(right);        if (op.equals("<"))        {          bool = lhs < rhs;        }        else if (op.equals(">"))        {          bool = lhs > rhs;        }        else if (op.equals("="))        {          bool = lhs == rhs;        }        else if (op.equals("<="))        {          bool = lhs <= rhs;        }        else if (op.equals(">="))        {          bool = lhs >= rhs;        }        else if (op.equals("!="))        {          bool = lhs != rhs;        }      }      // if two are char or date
      else if ((CheckString(left) && CheckString(right)) || (CheckDate(left) && CheckDate(right)))      {        String lhs = left;        String rhs = right;        if (op.equals("<"))        {          bool = lhs.compareTo(rhs) < 0;        }        else if (op.equals(">"))        {          bool = lhs.compareTo(rhs) > 0;        }        else if (op.equals("="))        {          bool = lhs.compareTo(rhs) == 0;        }        else if (op.equals("<="))        {          bool = lhs.compareTo(rhs) <= 0;        }        else if (op.equals(">="))        {          bool = lhs.compareTo(rhs) >= 0;        }        else if (op.equals("!="))        {          bool = lhs.compareTo(rhs) != 0;        }      }      // if compared to null value
      else if (left.equals("null") || right.equals("null"))      {        isUnknown = true;      }      // incomparable
      else      {        WhereIncomparableError();      }      if (isUnknown)      {        logicVal = LogicValue.U;      }      else if (bool)      {        logicVal = LogicValue.T;      }      else      {        logicVal = LogicValue.F;      }      result.addElement(logicVal);    }    return result;  }}String CompOperand(Vector < String > tblNames) :{  String tblName, colName, val;}{  (    LOOKAHEAD(TableName() < PERIOD > ColumnName())    (      tblName = TableName() < PERIOD > colName = ColumnName()      {        if (!tblNames.contains(tblName))        {          WhereTableNotSpecified();        }        else if (!GetAllColumns(tblName).contains(colName))        {          WhereColumnNotExist();        }        return tblName + "." + colName;      }    )  |    (      colName = ColumnName()      {        int cnt = 0;        for (int i = 0; i < tblNames.size(); i++)        {          String tblNameAt = tblNames.elementAt(i);          Vector < String > colsAt = GetAllColumns(tblNameAt);          if (colsAt.contains(colName))          {            cnt++;          }        }        if (cnt == 0)        {          WhereColumnNotExist();        }        else if (cnt > 1)        {          WhereAmbiguousReference();        }        return colName;      }    )  |    (      val = ComparableValue()      {        return val;      }    )  )}String ComparableValue() :{  Token t;}{  (    t = < DATE_VALUE >  | t = < INT_VALUE >  | t = < DIGIT >  | t = < CHAR_STRING >  )  {    return t.image;  }}Vector < LogicValue > NullPredicate(Vector < String > tblNames) :{  Vector < LogicValue > result = new Vector < LogicValue > ();  String tblName = null, colName, nullOp;}{  {    Vector < Vector < String >> allRecords = GetJoinedRecords(tblNames);    Vector < String > colNames = allRecords.elementAt(0);  }  (    LOOKAHEAD(TableName() < PERIOD > ColumnName())    (      tblName = TableName() < PERIOD > colName = ColumnName() nullOp = NullOperation()      {        if (!tblNames.contains(tblName))        {          WhereTableNotSpecified();        }        Vector < String > cols = GetAllColumns(tblName);        if (!cols.contains(colName))        {          WhereColumnNotExist();        }        int colIdx = GetColumnIndex(tblName, colName);        for (int i = 1; i < allRecords.size(); i++)        {          Vector < String > recordAt = allRecords.elementAt(i);          String valAt = recordAt.elementAt(colIdx);          if ((valAt.equals("null") && nullOp.equals("is null")) || (!valAt.equals("null") && nullOp.equals("is not null")))          {            result.addElement(LogicValue.T);          }          else if ((valAt.equals("null") && nullOp.equals("is not null")) || (!valAt.equals("null") && nullOp.equals("is null")))          {            result.addElement(LogicValue.F);          }        }      }    )  |    (      colName = ColumnName() nullOp = NullOperation()      {        int cnt = 0;        String matchTbl = new String();        for (int i = 0; i < tblNames.size(); i++)        {          String tblNameAt = tblNames.elementAt(i);          Vector < String > colsAt = GetAllColumns(tblNameAt);          if (colsAt.contains(colName))          {            matchTbl = tblNameAt;            cnt++;          }        }        if (cnt == 0)        {          WhereColumnNotExist();        }        else if (cnt > 1)        {          WhereAmbiguousReference();        }        int colIdx = GetColumnIndex(matchTbl, colName);        for (int i = 1; i < allRecords.size(); i++)        {          Vector < String > recordAt = allRecords.elementAt(i);          String valAt = recordAt.elementAt(colIdx);          if ((valAt.equals("null") && nullOp.equals("is null")) || (!valAt.equals("null") && nullOp.equals("is not null")))          {            result.addElement(LogicValue.T);          }          else if ((valAt.equals("null") && nullOp.equals("is not null")) || (!valAt.equals("null") && nullOp.equals("is null")))          {            result.addElement(LogicValue.F);          }        }      }    )  )  {    return result;  }}String NullOperation() :{  String nullOp;}{  (    nullOp = < IS_NULL >.image  | nullOp = < IS_NOT_NULL >.image  )  {    return nullOp;  }}void InsertQuery() :{  String tblName;  boolean isNewLine = false;}{  < INSERT_INTO > tblName = TableName()  {    if (CheckNoSuchTable(tblName))    {      NoSuchTable();    }  }  InsertColumnsAndSource(tblName)  (    < SEMICOLON >  |    (      (        ";\r"      | ";\n"      )      {        isNewLine = true;      }    )  )  {    InsertResult();    if (isNewLine)    {      System.out.print("SQL_2011-11693 > ");    }  }}void InsertColumnsAndSource(String tblName) :{  String colName;  Vector < String > cols = new Vector < String > ();  Vector < String > values;}{  (    cols = ColumnNameListInsert()  )?  values = ValueList()  // error checking...
  {    if ((colName = CheckInsertColumnExistence(tblName, cols)) != null)    {      InsertColumnExistenceError(colName);    }    else if (CheckInsertDuplicateColumn(cols))    {      InsertDuplicateColumnError();    }    CheckInsertColumnNonNullableAndTypeMismatch(tblName, cols, values);    if (CheckInsertDuplicatePrimaryKey(tblName, cols, values))    {      InsertDuplicatePrimaryKeyError();    }    else if (CheckInsertReferentialIntegrity(tblName, cols, values))    {      InsertReferentialIntegrityError();    }    // insert values into DB
    InsertValues(tblName, cols, values);  }}Vector < String > ColumnNameListInsert() :{  String colName;  Vector < String > cols;}{  {    cols = new Vector < String > ();  }  < LEFT_PAREN > colName = ColumnName()  {    cols.addElement(colName);  }  (    < COMMA > colName = ColumnName()    {      cols.addElement(colName);    }  )*  < RIGHT_PAREN >  {    return cols;  }}Vector < String > ValueList() :{  String val;  Vector < String > values;}{  {    values = new Vector < String > ();  }  < VALUES > < LEFT_PAREN > val = Value()  {    values.addElement(val);  }  (    < COMMA > val = Value()    {      values.addElement(val);    }  )*  < RIGHT_PAREN >  {    return values;  }}String Value() :{  Token t;  String val;}{  (t = < NULL >  {    return t.image;  }  )|  (    val = ComparableValue()    {      return val;    }  )}void DeleteQuery() :{  boolean isNewLine = false;  String tblName;  Vector < String > tblNames = new Vector < String > ();  Vector < LogicValue > eval = new Vector < LogicValue > ();  Vector < String > result = new Vector < String > ();}{  < DELETE_FROM >   tblName = TableName()  {    if (CheckNoSuchTable(tblName))    {      NoSuchTable();    }    tblNames.addElement(tblName);  }  (    eval = WhereClause(tblNames)  )?  {    // if there is no where clause
    if (eval.size() == 0)    {      int recordSize = myDB.getDB(tblName + " @record").size();      for (int i = 0; i < recordSize; i++)      {        eval.addElement(LogicValue.T);      }    }    CascadeDelete(tblName, eval);  }  (    < SEMICOLON >  |    (      (        ";\r"      | ";\n"      )      {        isNewLine = true;      }    )  )  {    if (isNewLine)    {      System.out.print("SQL_2011-11693 > ");    }  }}void Start() :{  Token t;}{  {    System.out.print("SQL_2011-11693 > ");  }  (    Command()  )*  {    System.out.println("Syntax error");    parser = new EG1(System.in);    handleSyntaxError(parser);  }}

SKIP :
{
  < _SPACE : < SPACE >>
| "\t"
| "\n"
| "\r"
}

TOKEN : // Elementary
{
  < SEMICOLON : ";" >
| < UNDERSCORE : "_" >
| < LEFT_PAREN : "(" >
| < RIGHT_PAREN : ")" >
| < COMMA : "," >
| < PERIOD : "." >
| < COMP_OP :
    "<"
  | ">"
  | "="
  | ">="
  | "<="
  | "!=" >
| < DIGIT : [ "0"-"9" ] >
| < SIGN :
    (
      "+"
    | "-"
    ) >
| < QUOTE : "'" >
| < NON_QUOTE_SPECIAL_CHARACTERS :
    "`"
  | "~"
  | "!"
  | "@"
  | "#"
  | "$"
  | "%"
  | "^"
  | "&"
  | "*"
  | "("
  | ")"
  | "_"
  | "-"
  | "+"
  | "="
  | "|"
  | "["
  | "]"
  | ":"
  | "<"
  | ","
  | ">"
  | "."
  | "?"
  | "/" >
| < ALPHABET : [ "A"-"Z", "a"-"z" ] >
| < SPACE : " " >
| < SPACES :
    " "
  | "\n"
  | "\r"
  | "\t" >
}

TOKEN : // Keywords
{
  < EXIT : "exit" >
| < CREATE_TABLE : "create table">
| < NOT_NULL : "not null" >
| < PRIMARY_KEY : "primary key" >
| < FOREIGN_KEY : "foreign key" >
| < REFERENCES : "references" >
| < INT : "int" >
| < CHAR : "char" >
| < DATE : "date" >
| < DROP_TABLE : "drop table">
| < SHOW_TABLES : "show tables" >
| < DESC : "desc">
| < SELECT : "select" >
| < AS : "as" >
| < FROM : "from" >
| < WHERE : "where" >
| < AND : "and" >
| < OR : "or" >
| < NOT : "not" >
| < IS_NULL : "is null" >
| < IS_NOT_NULL : "is not null" >
| < INSERT_INTO : "insert into" >
| < VALUES : "values" >
| < NULL : "null" >
| < DELETE_FROM : "delete from" >
}

TOKEN : // Comprised
{
  < LEGAL_IDENTIFIER :
    < ALPHABET >
    (
      < ALPHABET >
    | < UNDERSCORE >
    )* >
| < INT_VALUE : (< SIGN >)? (< DIGIT >)+ >
| < DATE_VALUE : < DIGIT > < DIGIT > < DIGIT > < DIGIT > "-" < DIGIT > < DIGIT > "-" < DIGIT > < DIGIT >>
| < CHAR_STRING :
    < QUOTE >
    (
      < DIGIT >
    | < ALPHABET >
    | < NON_QUOTE_SPECIAL_CHARACTERS >
    | < SPACE >
    )*
    < QUOTE >>
}